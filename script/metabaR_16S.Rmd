---
title: "metabaR"
author: "Marion Boisseaux"
date: "2/16/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#Package nécessaire
# install bioconductor dependencies
#install.packages("BiocManager")
#BiocManager::install("biomformat")

# install metabaR package
#install.packages("remotes")
#remotes::install_github("metabaRfactory/metabaR")

library(ape) #read fasta files
library(ggplot2)
library(ggpubr)
library(reshape2)
library(metabaR)
library(readr)
library(dplyr)
library(tidyverse)
library(tidyr)
library(stringr)
library(kableExtra)
```

#MetabarList

Creation de la MetarbarList avec les 4 objets:

*Motus : Motus en ligne et leur attributs en colonne (séquence, assignation, score d’assignation, etc)*
*PCR : PCRs en ligne et leur attributs en colonne (sample_id, type, type_de_contrôle)*
*Reads : une table avec les séquences en ligne et les Motus (abondance) en colonne*
*Sample : les échantillons en ligne et leurs infos associer en colonne (position GPS, altitude, milieu de prélèvement, etc). Mais si non disponible la liste des échantillons suffit*

For bacteria taxa assignation, it needs to be done on the cluster. it took 1h-2h.

**Option 1**: taxa assignation on silvangs: https://ngs.arb-silva.de/silvangs/

Create project and upload the .fasta file in the output of the obitool snakemake pipeline. And execute the project.

**Option 2**: do it with dada2 package. Download reference taxa: https://benjjneb.github.io/dada2/training.html 

I downloaded: silva_nr99_v138.1_train_set.fa.gz, then needs to be gzip on the cluster. 


```{r}
#don't run code: do on cluster !
#I have taxa_assign.R script on the cluster (here also below) that I launch in a batch using a bash script (also on the server)
library(metabaR)
library(dada2)

load("../resources/Metabarlist_natura_clean_16S_traits_alpha.Rdata") # ITS 

seqs<- natura_clean$motus$sequence
taxa <- assignTaxonomy(seqs, "../resources/silva_nr99_v138.1_train_set.fa") #from SILVA to download the latest version. It may need some unzipping to have the .fasta format

write.csv(taxa, "../results/taxa.16S.csv")
```

```{r MetabarList, include=FALSE}
#samples file preparation for the conversion
file_samples <- read.delim2("E:/DRYER_natura_data/16S/ngs_filter_16S.tab", header = FALSE)
file_samples <-as.data.frame(sapply(file_samples, function(x) gsub("\"", "", x)))
samples  <- file_samples %>%
  #select(project, organ, marker, samples_name, Family, Genus, Species) %>%
  rename(project = V1) %>%
  rename(sample_id = V2) %>%
  rename(tag = V3) %>%
  rename(primer_forward = V4) %>%
  rename(primer_reverse = V5) %>%
  rename(info = V6) %>%
  relocate(sample_id, .before = project) %>%
  separate(info, into = c('Family', 'Genus', 'Species'), sep = ",") %>%
  dplyr::select(-tag, -primer_forward, -primer_reverse)


samples <- samples %>% separate(sample_id, into = c("project", "s_project", "organ", "marker", "type", "code", "control_type"), sep = "_", remove = FALSE)

samples$CODE <- ifelse(grepl("^\\d+$", samples$code), samples$code, NA) #regular expression "^\\d+$" to match strings that contain only digits. The ^ and $ anchors ensure that the entire string is matched.  If the value matches the pattern, we assign it to the new column numeric_col, otherwise we assign NA.
samples$CONTROL_TYPE <- ifelse(grepl("\\D+", samples$code), samples$code, NA) #the pattern \\D+ to match one or more non-digit characters. If the value matches the pattern, we assign it to the new column character_col, otherwise we assign NA.


samples$CODE <- ifelse(is.na(samples$CODE), samples$control_type, samples$CODE)

samples <- samples %>%
  dplyr::select(-code, -control_type)%>%
  rename(code = CODE,
         control_type = CONTROL_TYPE) %>%
  relocate(control_type, .after = type) %>%
  relocate(code, .after = control_type)

samples$sample_id <- gsub("sample_", "", samples$sample_id)
rownames(samples) <- samples$sample_id
#unique samples meanwhile re-running the pipeline with the numbered controls.
# samples_unique <- samples[!duplicated(samples$sample_id),]
# samples_unique$sample_id <- gsub("sample_", "", samples_unique$sample_id)
# rownames(samples_unique) <- samples_unique$sample_id
# samples_unique <- samples_unique %>% separate(sample_id, into = c("project", "s_project", "organ", "marker", "code"), sep = "_", remove = FALSE)
#write.table(file_samples, file = "E:/DRYER_natura_data/16S/filesamples.txt", sep ="\t")

#pcrs
ngsfilter <-read.delim2("E:/DRYER_natura_data/16S/ngs_filter_16S.tab", header = FALSE)
ngsfilter <-as.data.frame(sapply(ngsfilter, function(x) gsub("\"", "", x)))
pcrs <- ngsfilter %>%
  rename(project = V1) %>%
  rename(sample_id = V2) %>%
  rename(tag = V3) %>%
  mutate(type = str_detect(sample_id, 'sample')) %>%
  mutate(type = ifelse(type %in% TRUE, 'sample', 'control')) %>%
  mutate(control_type = ifelse(str_detect(type, 'sample'), NA,
                               ifelse(str_detect(sample_id, 'sterilisation'), 'sequencing',  #i put sequencing but it's actually sterilisation. just to make sure the metabarlist works
                                      ifelse(str_detect(sample_id, 'extraction'), 'extraction', 'pcr')))) %>%
  dplyr::select(sample_id, type, control_type)

pcrs$sample_id <- gsub("sample_", "", pcrs$sample_id)

pcrs <- pcrs %>% 
  separate(sample_id, into = c("project", "s_project", "organ", "marker", "A", "CODE", "B"), sep = "_", remove = FALSE) %>%
  dplyr::select(-CODE)

pcrs$code<- ifelse(grepl("^\\d+$", pcrs$A), pcrs$A, NA) #regular expression "^\\d+$" to match strings that contain only digits. The ^ and $ anchors ensure that the entire string is matched.  If the value matches the pattern, we assign it to the new column numeric_col, otherwise we assign NA.

pcrs$code <- ifelse(is.na(pcrs$code), pcrs$B, pcrs$code)

pcrs <- pcrs %>%
  dplyr::select(-A, -B)

pcrs <- pcrs[!duplicated(pcrs$sample_id),]
rownames(pcrs) <- pcrs$sample_id
#write.table(pcrs, file= "E:/DRYER_natura_data/16S/pcrs.txt", sep ="\t")

#obifile
file_obitab <- read.delim2("E:/DRYER_natura_data/16S/results_16S_09052023/DRYER_natura_R1R2_good_demultiplexed_derepl_basicfilt_cl_agg.tab")
#colnames(file_obitab)
colnames(file_obitab) <- gsub("sample.", "", colnames(file_obitab)) # remove the pattern 'sample.' from column names

#read
colnames(file_obitab)
read <- file_obitab %>% dplyr::select(c(1,20:184))
read_t <- t(read[,-1])
read_t <- as.data.frame(read_t)
colnames(read_t) <- read$id
read_t[is.na(read_t)] <- 0 #Replace na values with 0 using is.na()
read_t <- as.matrix(read_t)

#motus
motus <- file_obitab[, c(1,3,19,205)] #take the sequence column
rownames(motus) <- motus$id

assign <- read.csv("E:/Assignation/16S/taxa.16S.csv", header = TRUE)
assign <- assign %>% rename(sequence= X)
assign$sequence <- tolower(assign$sequence) #convert in lowercase letters
assign_motus <- left_join(motus,assign, by= "sequence") 
dim(assign_motus) 
dim(motus) 
dim(assign) 

rownames(assign_motus) <- assign_motus$id


#dimensions are not the same, so investigate missing controls
read_t_essai <- as.data.frame(read_t)
setdiff(rownames(pcrs),rownames(read_t_essai))
# [1] "DRYER_natura_NA_16S_control_extraction_5" "DRYER_natura_NA_16S_control_PCR_21"      
# [3] "DRYER_natura_NA_16S_control_PCR_22" 

#remove missing controls
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_21")
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_22")
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_extraction_5")


samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_21")
samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_22")
samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_extraction_5")


#Metabarlist
MetabarList <- metabarlist_generator(reads = read_t , #165*11299
                                     motus = assign_motus, #11299*4 #ok
                                     pcrs = pcrs,  #165*8 #ok
                                     samples = samples) #165*11
```

# Diagnostic plots

Basic stats on the raw data

```{r}
# Compute the number of reads per pcr
MetabarList$pcrs$nb_reads <- rowSums(MetabarList$reads)
summary(MetabarList$pcrs$nb_reads) #
sum(MetabarList$pcrs$nb_reads) #2,032,202 de reads; mean: 12316
Nbr_reads <- MetabarList$pcrs

#total number of reads
sum(Nbr_reads$nb_reads) #[1] 2032202

#number of reads for all samples, removing control
Nbr_samples <-Nbr_reads %>% filter(type != "control") 
sum(Nbr_samples$nb_reads) #[1] 1953507

#number of reads for the leaf & root
leaf <- Nbr_samples %>% filter(organ != "leaf") 
sum(leaf$nb_reads) #[1] 875676
root <- Nbr_samples %>% filter(organ != "root") 
sum(root$nb_reads) #[1] 1077831

#removing reads below 300 reads
Nbr_samples <- Nbr_samples %>% filter(nb_reads > 300)
summary(Nbr_samples$nb_reads)
   # Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   # 2104   10101   12738   14799   17188   52727 
  
A <- ggplot(Nbr_reads, aes(x = nb_reads, fill = type))+
  geom_histogram() +
   theme_minimal() +
  theme(legend.position = "bottom")+
  theme(text = element_text(size = 12))
 

B <- ggplot(Nbr_samples, aes(x = nb_reads))+ #histogram on the samples only after removing one individual leaf that had a low number of reads
  geom_histogram() +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 40000, by = 5000))+
    theme(text = element_text(size = 12))

ggarrange(A, B, labels = c("nr_reads for all with controls" ,"nb_reads for samples (leaf & root)"))

# Compute the number of motus per pcr
MetabarList$pcrs$nb_motus <- rowSums(MetabarList$reads>0)
summary(MetabarList$pcrs$nb_motus <181) #20 beneath 181 
#average: 584.4 per samples

length(unique(MetabarList$motus$sequence))
# 11299 #nombre d'OTUs unique.

# Create an input table (named check1) for ggplot of 3 columns: 
#  (i) control type 
#  (ii) a vector indicated whether it corresponds to nb_reads or nb_motus, 
#  (iii) the corresponding values.

check1 <- melt(MetabarList$pcrs[,c("control_type", "nb_reads", "nb_motus")])
check1$control_type[which(check1$control_type == "sequencing")] <- "sterilisation"
ggplot(data <- check1, aes(x=control_type, y=value, color=control_type)) + 
  geom_boxplot() + theme_bw() + 
  geom_jitter(alpha=0.2) + 
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  facet_wrap(~variable, scales = "free_y") + 
  theme(axis.text.x = element_text(angle=45, h=1))

# Using the nb_reads and nb_motus defined previously

ggplot(MetabarList$pcrs, aes(x=nb_reads, y=nb_motus, color = control_type)) + 
  geom_point() + theme_bw() + 
  scale_y_log10() + scale_x_log10() + 
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey")



# Check results
summary_metabarlist(MetabarList)
```

$dataset_dimension
        n_row n_col
reads     165 11299
motus   11299    10
pcrs      165    10
samples   165    11

$dataset_statistics
        nb_reads nb_motus avg_reads sd_reads avg_motus
pcrs     2032202    11299  12316.38 8407.892  641.1697
samples  1953507    10843  14688.02 7534.524  744.2632
        sd_motus
pcrs    308.9424
samples 221.7162

# Rarefaction curves

```{r eval=FALSE, include=FALSE}
natura.raref = hill_rarefaction(MetabarList, nboot = 20, nsteps = 10)
head(natura.raref$hill_table)
gghill_rarefaction(natura.raref)

# Define a vector containing the Material info for each pcrs
material <- MetabarList$samples$Genus[match(MetabarList$pcrs$sample_id,
                                                rownames(MetabarList$samples))]

# Use of gghill_rarefaction requires a vector with named pcrs
material <- setNames(material,rownames(MetabarList$pcrs))

# Plot
p <- gghill_rarefaction(natura.raref, group=material) #contamination en vert sur le premier graphe??
```

# Detecting contaminants

Due to the tagjump bias, many genuine MOTUs that are abundant in samples can be detected in negative controls. Consequently, simply removing from the dataset any MOTU that occurs in negative controls is a **very bad idea.**

The function *contaslayer* relies on this assumption and detects MOTUs whose relative abundance across the whole dataset is highest in negative controls. Note however that this approach won’t be appropriate if the negative controls have been contaminated with biological samples. In this case,contaslayer should identify MOTUs that are dominants in samples.

The function contaslayer adds a new column in table motus indicating whether the MOTU is a genuine MOTU **TRUE** or a contaminant *FALSE*.

## sterilisation contaminants

```{r}
natura <- contaslayer(MetabarList,
                         control_types = "sequencing", #but sterilization
                         output_col = "not_a_sterilisation_conta")

table(natura$motus$not_a_sterilisation_conta)
# FALSE  TRUE 
#   77  11222 

# Identify the most common contaminant
# get contaminant ids
conta_sterilisation <- natura$motus$id[which(natura[["motus"]][["not_a_sterilisation_conta"]] == FALSE)]

conta_sterilisation<- as.data.frame(conta_sterilisation)

conta_sterilisation <- conta_sterilisation %>% 
  rename(id = conta_sterilisation)

conta_sterilisation <- left_join(conta_sterilisation, natura$motus)

# Compute relative abundance of all pcr contaminants together
a <- data.frame(conta.relab.sterilisation = rowSums(natura$reads[,!natura$motus$not_a_sterilisation_conta]) /
                                    rowSums(natura$reads))
# Add information on control types
a$control_type <- natura$pcrs$control_type[match(rownames(a), rownames(natura$pcrs))]

ggplot(a, aes(x=control_type, y=conta.relab.sterilisation, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10()

```



## pcrs contaminants
```{r}
natura <- contaslayer(natura,
                         control_types = "pcr",
                         output_col = "not_a_pcr_conta")

table(natura$motus$not_a_pcr_conta)
# FALSE  TRUE 
#   777  10522 

# Identify the most common contaminant
# get contaminant ids

conta_pcr <- natura$motus$id[which(natura[["motus"]][["not_a_pcr_conta"]] == FALSE)]
conta_pcr <- as.data.frame(conta_pcr)

conta_pcr <- conta_pcr %>% 
  rename(id = conta_pcr)

conta_pcr <- left_join(conta_pcr, natura$motus)

# Compute relative abundance of all pcr contaminants together
a$conta.relab.pcr <- rowSums(natura$reads[,!natura$motus$not_a_pcr_conta]) /
                                    rowSums(natura$reads)

ggplot(a, aes(x=control_type, y=conta.relab.pcr, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10()

```


## extraction contaminants

```{r extraction contaminants}

natura <- contaslayer(natura,
                         control_types = "extraction",
                         output_col = "not_an_extraction_conta")

table(natura$motus$not_an_extraction_conta)
#> 
#FALSE  TRUE 
 #  75  11224 
conta_extraction <- natura$motus$id[which(natura[["motus"]][["not_an_extraction_conta"]] == FALSE)]
conta_extraction <- as.data.frame(conta_extraction)


conta_extraction <- conta_extraction %>% 
    rename(id = conta_extraction)

conta_extraction <- left_join(conta_extraction, natura$motus)

# Compute relative abundance of all pcr contaminants together

a$conta.relab.extraction <- rowSums(natura$reads[,!natura$motus$not_an_extraction_conta]) /
                                    rowSums(natura$reads)

ggplot(a, aes(x=control_type, y=conta.relab.extraction, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10() #ca va pas trop de conta dans les echantillons

```

##flag contaminants

Overall, samples yield much less amounts of extraction contaminants than experimental negative controls. No pcrs corresponding to samples have > 10% of their reads corresponding to contaminants. We can still flag the controls:

```{r}
#flag pcrs with total contaminant relative abundance > 10% of reads
#1 for contaminants that came from pcr
#2 for contaminants that came from extraction

#to get the detail
# natura$pcrs$low_contamination_level <-
#   ifelse(a$conta.relab.sterilisation[match(rownames(natura$pcrs), rownames(a))]>1e-1,  1,
#   ifelse(a$conta.relab.extraction[match(rownames(natura$pcrs), rownames(a))]>1e-1,  2,
#   ifelse(a$conta.relab.pcr[match(rownames(natura$pcrs), rownames(a))]>1e-1, 3, 0)))

#to do it all at once
natura$pcrs$low_contamination_level <-
  ifelse(a$conta.relab.sterilisation[match(rownames(natura$pcrs), rownames(a))]>1e-1,  F, 
  ifelse(a$conta.relab.extraction[match(rownames(natura$pcrs), rownames(a))]>1e-1,  F,
  ifelse(a$conta.relab.pcr[match(rownames(natura$pcrs), rownames(a))]>1e-1, F, T)))

# Proportion of potentially functional (TRUE) vs. failed (FALSE) pcrs
# (controls included) based on this criterion
table(natura$pcrs$low_contamination_level) / nrow(natura$pcrs)
#0, 0.94545455 : no contamination (all samples)       
#1, 0.01212121 : conta from sterilisation (2, one from the sterilisation and one pcrs)   
#2  0.03030303 : conta from extraction (5: 2 ext + 3 pcr) 
#3  0.01212121 : conta from pcr (2 pcr)


#all at once
#      FALSE       TRUE 
# 0.05454545 0.94545455 
```

## spurious or non-target MOTUs

Non-target sequences can be amplified if the primers are not specific enough. On the other hand, some highly degraded sequences can be produced throughout the data production process, such as primer dimers, or chimeras from multiple parents (hereafter referred to as spurious MOTUs). To detect these, one can use the information related to taxonomic assignments and associated similarity scores.

Since the dataset was obtained with primers that target 16S, other MOTUs should be excluded. At this stage of the analysis, we only flag MOTUs based on this criterion.

```{r}
#Flag MOTUs corresponding to target (TRUE) vs. non-target (FALSE) taxa
natura$motus$target_taxon <- grepl("Bacteria", natura$motus$Kingdom)

# Proportion of each of these over total number of MOTUs
table(natura$motus$target_taxon) / nrow(natura$motus)

#   FALSE       TRUE 
# 0.03699442 0.96300558 
#ce sont des archées ou non assignation?

# Intersection with extraction contaminant flags (not contaminant = T)
table(natura$motus$target_taxon,
      natura$motus$not_a_sterilisation_conta) #7 MOTUs as non-taget, which were already flagged as potential sterilisation conta

table(natura$motus$target_taxon,
      natura$motus$not_an_extraction_conta) #4 MOTUs as non-taget, which were already flagged as potential ext conta

table(natura$motus$target_taxon,
      natura$motus$not_a_pcr_conta) #53 MOTUs as non-taget, which were already flagged as potential pcr conta
```

Next, we want to identify MOTUs whose sequence is too dissimilar from references. This filtering criterion relies on the assumption that current reference databases capture most of the diversity at broad taxonomic levels (i.e. already have for example at least one representative of each phyla). Considering this, MOTUs being too distant from reference databases are more likely to be a degraded sequence, especially if such MOTUs are relatively numerous and of low abundance. To assess this, one can use the distribution of MOTU similarity scores, weighted and unweighted by their relative abundance.

```{r}
# Plot the unweighted distribution of MOTUs similarity scores
a <-
  ggplot(natura$motus, aes(x=similarity)) +
  geom_histogram(color="grey", fill="white", bins=20) +
  geom_vline(xintercept = 80, col="orange", lty=2) +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(x="% similarity against best match", y="# MOTUs")

#But silva lready filtered the MOTU correspondances
# classification similarity
# 93
# The minimal percent similarity to the closest relative as reported by BLAST according to ((alignment coverage + alignment quality)/2) that is used for classification.
```

## detecting PCR outliers

A first way to identify failed PCRs is to flag them based on the pcr sequencing depth

```{r}
ggplot(natura$pcrs, aes(nb_reads, fill= type)) +
    geom_histogram(bins=40, color="grey") +
    geom_vline(xintercept = 1e3, lty=2, color="orange") + # threshold
    scale_x_log10() +
    labs(x="# Reads (with all MOTUs and PCRs)",
        y="# PCRs") +
    theme_bw() +
    theme(panel.grid = element_blank())
#fortunately, samples yield high amount of reads.
# Flag pcrs with an acceptable sequencing depth (TRUE) or inacceptable one (FALSE)
natura$pcrs$seqdepth_ok <- ifelse(natura$pcrs$nb_reads < 1e3, F, T)

# Proportion of each of these over total number of pcrs, control excluded
table(natura$pcrs$seqdepth_ok[natura$pcrs$type=="sample"]) /
  nrow(natura$pcrs[natura$pcrs$type=="sample",])
# 
# FALSE        TRUE 
# 0.007518797 0.992481203 

```

## lowering tag-jumps

Tag-jumps are frequency-dependent, i.e. abundant genuine MOTUs are more likely to be found in low abundance in samples were they are not supposed to be than rare genuine MOTUs. To reduce the amount of such false positives, the function tagjumpslayer considers each MOTU separately and corrects its abundance in pcrs (see tagjumpslayer help for more information on possible correction methods) when the MOTU relative abundance over the entire dataset is below a given threshold. Such data a curation strategy is similar to what has been proposed by Esling, Lejzerowicz, and Pawlowski (2015). Effect of this threshold can be evaluated by testing how this filtration procedure affects basic dataset characteristics (e.g. # MOTUs or reads) at different levels, as exemplified below.

```{r}
# Define a vector of thresholds to test
thresholds <- c(0,1e-4,1e-3, 1e-2, 3e-2, 5e-2)

# Run the tests and stores the results in a list
tests <- lapply(thresholds, function(x) tagjumpslayer(natura,x))
names(tests) <- paste("t_", thresholds, sep="")

# Format the data for ggplot with amount of reads at each threshold
tmp <- melt(as.matrix(do.call("rbind", lapply(tests, function(x) rowSums(x$reads)))))
colnames(tmp) <- c("threshold", "sample", "abundance")

# Add richness in MOTUs at each threshold
tmp$richness <-
  melt(as.matrix(do.call("rbind", lapply(tests, function(x) {
    rowSums(x$reads > 0)
  }))))$value

# Add control type information on pcrs and make data curation threshold numeric
tmp$controls <- natura$pcrs$control_type[match(tmp$sample, rownames(natura$pcrs))]
tmp$threshold <- as.numeric(gsub("t_", "", tmp$threshold))

# New table formatting for ggplot
tmp2 <- melt(tmp, id.vars=colnames(tmp)[-grep("abundance|richness", colnames(tmp))])

ggplot(tmp2, aes(x=as.factor(threshold), y=value)) +
  geom_boxplot(color="grey40") +
  geom_vline(xintercept = which(levels(as.factor(tmp2$threshold)) == "0.01"), col="orange", lty=2) +
  geom_jitter(aes(color=controls), width = 0.2, alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  facet_wrap(~variable+controls, scale="free_y", ncol=4) +
  theme_bw() +
  scale_y_log10() +
  labs(x="MOTU pcr : total abundance filtering threshold", y="# Reads/MOTUs") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        axis.text.x = element_text(angle=40, h=1),
         legend.position = "none")
# A threshold of 0.01 leads to a drop in both the number of reads and of MOTUs in sequencing negative controls. This drop is also noticeable in terms of the number of MOTUs in pcrs obtained from other controls as compared to those obtained from samples. The former are expected to be void of environmental MOTUs, and tag-jumps should be more visible/important in these pcrs. Note that this procedure primarily affects MOTU diversity in pcrs, and poorly the number of reads in pcrs.
# 
# As for above, pcrs containing large amounts of MOTUs identified as potentially artifactual or where tag-jumps filtering strongly affects the number of reads in pcrs can be flagged as potentially failed
```

## summarizing the noise in the natura dataset

We can now get an overview of the amount of noise identified with the criteria used above, for both the number of MOTUs and their associated readcount.

```{r}
# Create a table of MOTUs quality criteria
# noise is identified as FALSE in natura, the "!" transforms it to TRUE
motus.qual <- !natura$motus[,c("not_an_extraction_conta", "not_a_pcr_conta", "not_a_sterilisation_conta", "target_taxon")]
colnames(motus.qual) <- c("extraction_conta", "pcr_conta", "sterilisation_conta", "untargeted_taxon")

# Proportion of MOTUs potentially artifactual (TRUE) based on the criteria used
prop.table(table(apply(motus.qual, 1, sum) > 0))

# 
#    FALSE     TRUE 
# 0.5355341 0.4644659 

# Corresponding proportion of artifactual reads (TRUE)
#get the number of reads per motus
natura$motus$count <- colSums(natura$reads>0)
prop.table(xtabs(natura$motus$count~apply(motus.qual, 1, sum) > 0))
#    FALSE      TRUE 
# 0.5815413 0.4184587 

# Proportion of MOTUs and reads potentially artifactual for each criterion
apply(motus.qual, 2, sum) / nrow(motus.qual)
apply(motus.qual, 2, function(x) sum(natura$motus$count[x])/sum(natura$motus$count))

tmp.motus <-
  apply(sapply(1:ncol(motus.qual), function(x) {
    ifelse(motus.qual[,x]==T, colnames(motus.qual)[x], NA)}), 1, function(x) {
      paste(sort(unique(x)), collapse = "|")
      })
tmp.motus <- as.data.frame(gsub("^$", "not_artefactual", tmp.motus))
colnames(tmp.motus) <-  "artefact_type"

ggplot(tmp.motus, aes(x=1, fill=artefact_type)) +
    geom_bar() +  xlim(0, 2) +
    labs(fill="Artifact type") +
    coord_polar(theta="y") + theme_void() +
    scale_fill_brewer(palette = "Set3") +
    theme(legend.direction = "vertical") +
    ggtitle("MOTUs artefacts overview")

# 
# The above shows that MOTUs flagged as potentially artefactual account for ca. 10% of the dataset’s diversity and roughly the same in terms of readcount. Most of these artifact MOTUs are rare and correspond to sequences which are potentially highly degraded, with very low sequence similarity against the EMBL reference database. The most abundant artifacts MOTUs were identified as contaminants.
#let's do the same for pcrs
# Create a table of pcrs quality criteria
# noise is identified as FALSE in natura, the "!" transforms it to TRUE

pcrs.qual <- !natura$pcrs[,c("low_contamination_level", "seqdepth_ok")]
colnames(pcrs.qual) <- c("high_contamination_level", "low_seqdepth")


# Proportion of pcrs potentially artifactual (TRUE) based on the criteria used
# excluding controls
prop.table(table(apply(pcrs.qual[natura$pcrs$type=="sample",], 1, sum) > 0))

# FALSE        TRUE 
# 0.992481203 0.007518797 

# Proportion of MOTUs and reads potentially artifactual for each criterion
apply(pcrs.qual[natura$pcrs$type=="sample",], 2, sum) / nrow(pcrs.qual[natura$pcrs$type=="sample",])
# 
# low_seqdepth high_contamination_level 
#              0.007518797              0.000000000 

tmp.pcrs <-
  apply(sapply(1:ncol(pcrs.qual), function(x) {
    ifelse(pcrs.qual[natura$pcrs$type=="sample",x]==T,
           colnames(pcrs.qual)[x], NA)}), 1, function(x) {
      paste(sort(unique(x)), collapse = "|")
      })
tmp.pcrs <- as.data.frame(gsub("^$", "not_artefactual", tmp.pcrs))

colnames(tmp.pcrs) <- "artefact_type"

ggplot(tmp.pcrs, aes(x=1, fill=artefact_type)) +
    geom_bar() +  xlim(0, 2) +
    labs(fill="Artifact type") +
    coord_polar(theta="y") + theme_void() +
    scale_fill_brewer(palette = "Set3") +
    theme(legend.direction = "vertical") +
    ggtitle("PCR artefacts overview")
```

# Data cleaning and aggregation

The final stage of the analysis consists in removing data based on the criteria defined above and aggregating pcrs to get rid of technical replicates. Here, the decision of which of these flagged criteria to use rests with the user, depending on how they feel the tagged errors impact on the characteristics of their dataset.

## removing spurious signal

First, we will remove suprious MOTUs, PCRs and adjusting read counts by removing tag-jumps . At this stage of the analysis, *controls are no longer necessary*, and so can also be removed from the dataset.

```{r}
# Use tag-jump corrected metabarlist with the threshold identified above
tmp <- tests[["t_0.01"]]

#for pcrs
# Subset on pcrs and keep only controls
tmp_clean <- subset_metabarlist(tmp, "pcrs",
                          indices = rowSums(tmp$pcrs[,c("low_contamination_level","seqdepth_ok")]) == 2 &
                                    tmp$pcrs$type == "sample")
summary_metabarlist(tmp_clean)

# Subset on MOTUs: we keep motus that are defined as TRUE following the
# three criteria below (sum of three TRUE is equal to 3 with the rowSums function)
natura_clean <- subset_metabarlist(tmp_clean, "motus",
                          indices = rowSums(tmp_clean$motus[,c("not_an_extraction_conta", "target_taxon",
                                                 "not_a_pcr_conta", "not_a_sterilisation_conta")]) == 4)
summary_metabarlist(natura_clean)
# 
# dataset_dimension
#         n_row n_col
# reads     132  6051
# motus    6051    14
# pcrs      132    12
# samples   132    11
# 
# $dataset_statistics
#         nb_reads nb_motus avg_reads sd_reads avg_motus
# pcrs     1460111     6051  11061.45 5746.018  408.4697
# samples  1460111     6051  11061.45 5746.018  408.4697
#         sd_motus
# pcrs    121.7422
# samples 121.7422


#check if previsous subsetting lead to NAs
if(sum(colSums(tmp_clean$reads)==0)>0){print("empty motus present")}
if(sum(rowSums(natura_clean$reads)==0)>0){print("empty pcrs present")}

natura_clean$motus$count = colSums(natura_clean$reads)
natura_clean$pcrs$nb_reads_postmetabaR = rowSums(natura_clean$reads)
natura_clean$pcrs$nb_motus_postmetabaR = rowSums(ifelse(natura_clean$reads>0, T, F))

check <- melt(natura_clean$pcrs[,c("nb_reads", "nb_reads_postmetabaR",
                               "nb_motus", "nb_motus_postmetabaR")])
check$type <- ifelse(grepl("motus", check$variable), "richness", "abundance")

ggplot(data = check, aes(x = variable, y = value)) +
  geom_boxplot( color = "darkgrey") +
  geom_jitter(alpha=0.1, color = "darkgrey") +
  theme_bw() +
  facet_wrap(~type, scales = "free", ncol = 5) +
  theme(axis.text.x = element_text(angle=45, h=1)) 

#The sequencing depth was not greatly affected by the trimming. But the richness of pcrs was lowered
```

Let’s now see if the signal is changed in terms of beta diversity:

```{r organ, species}
# Get row data only for samples
tmp <- subset_metabarlist(natura, table = "pcrs",
                          indices = natura$pcrs$type == "sample")

# Add sample biological information for checks
tmp$pcrs$organ <- tmp$samples$organ[match(tmp$pcrs$sample_id, rownames(tmp$samples))]
tmp$samples$name <- paste0(tmp$samples$Genus, "_", tmp$samples$Species)
tmp$pcrs$name <- tmp$samples$name[match(tmp$pcrs$sample_id, rownames(tmp$samples))]
tmp$pcrs$family <- tmp$samples$Family[match(tmp$pcrs$sample_id, rownames(tmp$samples))]

natura_clean$pcrs$organ <-
  natura_clean$samples$organ[match(natura_clean$pcrs$sample_id,
                                        rownames(natura_clean$samples))]

natura_clean$samples$name <- paste0(natura_clean$samples$Genus, "_", natura_clean$samples$Species)
natura_clean$pcrs$name <- natura_clean$samples$name[match(natura_clean$pcrs$sample_id, rownames(natura_clean$samples))]
natura_clean$pcrs$family <- natura_clean$samples$Family[match(natura_clean$pcrs$sample_id, rownames(natura_clean$samples))]


# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = paste(tmp$pcrs$organ, tmp$pcrs$name, sep = " | "))

mds2 <- check_pcr_repl(natura_clean,
                       groups =  paste(natura_clean$pcrs$organ, natura_clean$pcrs$name, sep = " | "))

# Custom colors
a <- mds1 + labs(color = "organ | name") +
#  scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
b <- mds2 + labs(color = "organ | name") +
  #scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  ggtitle("Clean data")

# Assemble plots
species <- ggarrange(a, b, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ_species.jpeg", plot = species, width = 10, height = 8)
```

```{r organ, eval=FALSE, include=FALSE}
# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = paste(tmp$pcrs$organ, tmp$pcrs$family, sep = " | "))

mds2 <- check_pcr_repl(natura_clean,
                       groups =  paste(natura_clean$pcrs$organ, natura_clean$pcrs$family, sep = " | "))

# Custom colors
c <- mds1 + labs(color = "organ | family") +
#  scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
d <- mds2 + labs(color = "organ | family") +
  #scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  ggtitle("Clean data")

# Assemble plots
family <- ggarrange(c, d, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ_family.jpeg", plot = family, width = 10, height = 8)
```

```{r eval=FALSE, include=FALSE}
# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = tmp$pcrs$organ)

mds2 <- check_pcr_repl(natura_clean,
                       groups = natura_clean$pcrs$organ)

# Custom colors
a <- mds1 + labs(color = "organ") +
  scale_color_manual(values = c("#6bbf59", "#E79F02")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
b <- mds2 + labs(color = "organ") +
  scale_color_manual(values = c("#6bbf59", "#E79F02")) +
  ggtitle("Clean data")

# Assemble plots
organ <- ggarrange(a, b, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ.jpeg", plot = organ, width = 10, height = 8)

#for presentation 
pres_organ <- mds2 + labs(color = "organ") +
   scale_color_manual(values = c("#6bbf59", "#E79F02")) +
   theme_light(base_size = 22) +
   theme(legend.position = "none")
ggsave(filename = "PCoA_organ_pres.jpeg", plot = pres_organ, width = 10, height = 8)
```

## data aggregation

normally aggregate the replications, but let's try aggregating the individuals of same species

```{r eval=FALSE, include=FALSE}
#natura_agg <- aggregate_pcrs(natura_clean)
#summary_metabarlist(natura_agg)
```


# Cleaned data

```{r setup, include=FALSE}

knitr::opts_chunk$set(eval = FALSE, include = FALSE)
#no need for below, we have all the info with the NewMetabarlist_clean
#both organs
save(natura_clean, file = "./results/Metabarlist_natura_clean_16S.Rdata")

write.csv(natura_clean$motus,"motus_without_contamiant.csv")
write.csv(t(natura_clean$motus),"transposed_motus_without_contamiant.csv")
write.csv(natura_clean$reads,"reads_without_contamiant.csv")
write.csv(t(natura_clean$reads),"transposed_reads_without_contamiant.csv")
write.csv(natura_clean$samples,"samples_without_contamiant.csv")
write.csv(natura_clean$pcrs,"pcrs_without_contamiant.csv")
write.csv(t(natura_clean$pcrs),"transposed_pcrs_without_contamiant.csv")

#only leaves
leaf_metabar_clean <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")
save(leaf_metabar_clean, file = "./results/Metabarlist_natura_clean_16S_leaf.Rdata")
write.csv(leaf_metabar_clean$motus,"leaf_motus_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$motus),"leaf_transposed_motus_without_contamiant.csv")
write.csv(leaf_metabar_clean$reads,"leaf_reads_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$reads),"leaf_transposed_reads_without_contamiant.csv")
write.csv(leaf_metabar_clean$samples,"leaf_samples_without_contamiant.csv")
write.csv(leaf_metabar_clean$pcrs,"leaf_pcrs_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$pcrs),"leaf_transposed_pcrs_without_contamiant.csv")

#only roots
root_metabar_clean <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")
save(root_metabar_clean, file = "./results/Metabarlist_natura_clean_16S_root.Rdata")
write.csv(root_metabar_clean$motus,"root_motus_without_contamiant.csv")
write.csv(t(root_metabar_clean$motus),"root_transposed_motus_without_contamiant.csv")
write.csv(root_metabar_clean$reads,"root_reads_without_contamiant.csv")
write.csv(t(root_metabar_clean$reads),"root_transposed_reads_without_contamiant.csv")
write.csv(root_metabar_clean$samples,"root_samples_without_contamiant.csv")
write.csv(root_metabar_clean$pcrs,"root_pcrs_without_contamiant.csv")
write.csv(t(root_metabar_clean$pcrs),"root_transposed_pcrs_without_contamiant.csv")
```

#stats
```{r}
# Compute the number of reads per pcr
natura_clean$pcrs$nb_reads <- rowSums(natura_clean$reads)

summary(natura_clean$pcrs$nb_reads) #
sum(natura_clean$pcrs$nb_reads) #1,460,111 de reads; mean: 12316
Nbr_reads <- natura_clean$pcrs

#total number of reads
sum(Nbr_reads$nb_reads) #[1]1460111

#number of reads for all samples, removing control
Nbr_samples <-Nbr_reads %>% filter(type != "control") 
sum(Nbr_samples$nb_reads) #[1] 1460111

#number of reads for the leaf & root
leaf <- Nbr_samples %>% filter(organ != "leaf") 
sum(leaf$nb_reads) #[1] 621044
root <- Nbr_samples %>% filter(organ != "root") 
sum(root$nb_reads) #[1]  839067

#removing reads below 300 reads
Nbr_samples <- Nbr_samples %>% filter(nb_reads > 300)
summary(Nbr_samples$nb_reads)
# Min. 1st Qu.  Median    Mean 3rd Qu. 
# 993    7512    9998   11061   13518   37366 


length(unique((natura_clean$motus$id))) #6051
leaf <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")
length(unique((leaf$motus$id))) #3705
root <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")
length(unique((root$motus$id))) # 4310


```

# Visualisation

## phylum
```{r}
load("./results/Metabarlist_natura_clean_16S.Rdata")
leaf <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")
# Aggregate the metabarlist at the class level
leaf_phy <-  aggregate_motus(leaf, groups= leaf$motus$Phylum)

leaf_phy$samples$Name <- paste0(substr(leaf_phy$samples$Genus, 1, 1), ".", " ", leaf_phy$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(leaf_phy$reads, by = list(
    paste(leaf_phy$samples$Name)), sum))

colnames(tmp) <- c("Name", "Phylum", "Value")

# Calculate the total abundance per phylum
phylum_abundance <- aggregate(Value ~ Phylum, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(phylum_abundance$Value)
phylum_proportions <- phylum_abundance %>% mutate(Proportion = Value / total_sum *100)
phylum_proportions

#                        Phylum   Value    Proportion
# 
# 1              Abditibacteriota    301  0.03587318
# 2               Acidobacteriota  17541  2.09053627
# 3              Actinobacteriota 433451 51.65868757
# 4                    Aquificota     43  0.00512474
# 5                Armatimonadota    347  0.04135546
# 6                  Bacteroidota   8760  1.04401675
# 7              Bdellovibrionota    476  0.05672968
# 8              Campylobacterota      4  0.00047672
# 9                   Chloroflexi  39991  4.76612714
# 10         Coprothermobacterota      2  0.00023836
# 11                Cyanobacteria   5082  0.60567273
# 12                 Deinococcota   1420  0.16923559
# 13                 Dependentiae     14  0.00166852
# 14             Desulfobacterota     37  0.00440966
# 15              Elusimicrobiota     42  0.00500556
# 16                      FCPU426      6  0.00071508
# 17               Fibrobacterota     23  0.00274114
# 18                   Firmicutes  60983  7.26795357
# 19               Fusobacteriota     59  0.00703162
# 20              Gemmatimonadota   1077  0.12835685
# 21             Latescibacterota      2  0.00023836
# 22                       MBNT15      3  0.00035754
# 23                  Myxococcota   6862  0.81781312
# 24                           NA    344  0.04099792
# 25                        NB1-j      2  0.00023836
# 26                 Nitrospirota     34  0.00405212
# 27              Patescibacteria    380  0.04528840
# 28              Planctomycetota     12  0.00143016
# 29               Proteobacteria 261032 31.10979219
# 30                      RCP2-54     30  0.00357540
# 31 SAR324 clade(Marine group B)     42  0.00500556
# 32                Spirochaetota     61  0.00726998
# 33                      Sva0485      2  0.00023836
# 34                 Synergistota      4  0.00047672
# 35                 Thermotogota     23  0.00274114
# 36            Verrucomicrobiota    566  0.06745588
# 37                        WPS-2      6  0.00071508
# 38                 Zixibacteria      3  0.00035754


# Sort the data by the total abundance in descending order
top_phyla <- head(phylum_abundance$Phylum[order(phylum_abundance$Value, decreasing = TRUE)],6)

# Classify other phyla as 'Others'
tmp <- tmp %>%
  mutate(Phylum2 = ifelse(Phylum %in% top_phyla, paste0(Phylum), "Others"))

# total abundance per species
sample_abundance <- tmp %>%
  group_by(Name) %>%
  summarize(TotalValue = sum(Value))

# Merge the total sample abundance with the data
tmp <- merge(tmp, sample_abundance, by = "Name")

# Calculate the relative abundances
tmp$RelativeAbundance <- tmp$Value / tmp$TotalValue

# Sort the data within each sample by increasing relative abundance
tmp <- tmp %>%
  group_by(Name) %>%
  arrange(RelativeAbundance)

tmp$Phylum2[which(tmp$Phylum2== "NA")] <- "unidentified"

# Define the manual colors for six levels
custom_colors13 <- c("#774C22", "#965326", 
                     #"#FFE898", 
                     "#C1A13E", 
                     #"#5D641E",
                     "#BAD0C4", #muco
                     "#7CAED1", "#98D3F1", 
                       "#EFEFBB", "#FFD34C")
#custom_colors6 <- c("#dad7cd", "#386641", "#A7C957", "#a3b18a", "#B5E48C", "#432818")

#plot phyla
A <- tmp %>%
    mutate(Name = gsub("_", " ", Name)) %>% 
    ggplot(aes(x=Name, y=RelativeAbundance, fill=Phylum2)) +
    geom_bar(position="stack", stat="identity") +
    labs(x=NULL, y="", fill="Phylum") +
    scale_fill_manual(values= custom_colors13) +
    coord_flip() + scale_x_discrete(limits = rev(levels(as.factor(tmp$Name))))+
    theme_bw() +
    theme(legend.position = "bottom",axis.text.y = element_text(face = "italic")) +
    ggtitle("Leaf")
    
A

## root

root <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")

# Aggregate the metabarlist at the class level
root_phy <-  aggregate_motus(root, groups= root$motus$Phylum)

root_phy$samples$Name <- paste0(substr(root_phy$samples$Genus, 1, 1), ".", " ", root_phy$samples$Species)

# Aggregate per organ/genus
tmp_root <-  melt(aggregate(root_phy$reads, by = list(
    paste(root_phy$samples$Name)), sum))

colnames(tmp_root) <- c("Name", "Phylum", "Value")

# Calculate the total abundance per phylum
phylum_abundance <- aggregate(Value ~ Phylum, data = tmp_root, sum)
options(scipen = 999)
total_sum <- sum(phylum_abundance$Value)
phylum_proportions <- phylum_abundance %>% mutate(Proportion = Value / total_sum *100)
phylum_proportions


# Sort the data by the total abundance in descending order
top_phyla <- head(phylum_abundance$Phylum[order(phylum_abundance$Value, decreasing = TRUE)],6)

# Classify other phyla as 'Others'
tmp_root <- tmp_root %>%
  mutate(Phylum2 = ifelse(Phylum %in% top_phyla, paste0(Phylum), "Others"))

# total abundance per species
sample_abundance <- tmp_root %>%
  group_by(Name) %>%
  summarize(TotalValue = sum(Value))

# Merge the total sample abundance with the data
tmp_root <- merge(tmp_root, sample_abundance, by = "Name")

# Calculate the relative abundances
tmp_root$RelativeAbundance <- tmp_root$Value / tmp_root$TotalValue

# Sort the data within each sample by increasing relative abundance
tmp_root <- tmp_root %>%
  group_by(Name) %>%
  arrange(RelativeAbundance)

# Define the manual colors for six levels
custom_colors13 <- c("#774C22", "#965326", #acido et actino
                     #"#C1A13E", 
                     "#5D641E", #myxo
                     "#BAD0C4", #chloroflexi
                     "#7CAED1", "#98D3F1", #fimicutes, others
                    #"#DEC769",
                    "#EFEFBB",  #proteo
                    "#FFD34C")
#custom_colors6 <- c("#dad7cd", "#386641", "#A7C957", "#a3b18a", "#B5E48C", "#432818")

tmp_root$Phylum2[which(tmp_root$Phylum2== "NA")] <- "unidentified"

#convert 'position' to factor and specify level order
tmp_root$Phylum2 <- factor(tmp_root$Phylum2 , levels=c('Acidobacteriota', 'Actinobacteriota', 'Myxococcota', 'Chloroflexi', 'Firmicutes', 'Others', 'Proteobacteria'))

#plot phyla
B <- tmp_root %>%
    mutate(Name = gsub("_", " ", Name)) %>% 
    ggplot(aes(x=Name, y=RelativeAbundance, fill=Phylum2)) +
    geom_bar(position="stack", stat="identity") +
    labs(x=NULL, y="", fill="Phylum") +
    scale_fill_manual(values= custom_colors13) +
    coord_flip() + scale_x_discrete(limits = rev(levels(as.factor(tmp_root$Name))))+
    theme_bw() +
    theme(legend.position = "bottom",axis.text.y = element_text(face = "italic")) +
    ggtitle("Root")
    
B

phylum <- ggarrange(A, B, ncol = 1, nrow = 2)
phylum
ggsave("./results/phylum_bacteria.jpeg", phylum, width = 7, height = 6)
```


## Order
```{r}
load("./results/Metabarlist_natura_clean_16S.Rdata")
leaf <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")

#leaf$motus$Phylum_Class_Order <- paste0(leaf$motus$Phylum, ";", " ", leaf$motus$Class, ";", " ",leaf$motus$Order)

leaf$motus$Order <- paste0("o__",leaf$motus$Order)

# Aggregate the metabarlist at the class level
#leaf_order <-  aggregate_motus(leaf, groups= leaf$motus$Phylum_Class_Order)
leaf_order <-  aggregate_motus(leaf, groups= leaf$motus$Order)
leaf_order$samples$Species <- str_sub(leaf_order$samples$Species,1,-2)
leaf_order$samples$Name <- paste0(substr(leaf_order$samples$Genus, 1, 1), ".", " ", leaf_order$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(leaf_order$reads, by = list(
    paste(leaf_order$samples$Name)), sum))

colnames(tmp) <- c("Name", "Order", "Value")

# Calculate the total abundance per Class
Order_abundance <- aggregate(Value ~ Order, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(Order_abundance$Value)
Order_proportions <- Order_abundance %>% mutate(Proportion = Value / total_sum *100)
Order_proportions

top_10_proportions <- Order_proportions %>% 
  arrange(desc(Proportion)) %>% 
  head(10)

                                                    Order  Value Proportion
1     Actinobacteriota; Actinobacteria; Corynebacteriales 147742  17.607891
2        Proteobacteria; Alphaproteobacteria; Rhizobiales 133217  15.876801
3            Actinobacteriota; Actinobacteria; Frankiales  79153   9.433454
4  Actinobacteriota; Thermoleophilia; Solirubrobacterales  55864   6.657871
5     Actinobacteriota; Actinobacteria; Pseudonocardiales  50485   6.016802
6     Actinobacteriota; Actinobacteria; Micromonosporales  47323   5.639955
7      Proteobacteria; Alphaproteobacteria; Rickettsiales  37717   4.495112
8    Proteobacteria; Gammaproteobacteria; Burkholderiales  36873   4.394524
9               Chloroflexi; Chloroflexia; Chloroflexales  27723   3.304027
10                        Firmicutes; Bacilli; Bacillales  24773   2.952446


# Sort the data by the total abundance in descending order
top_phyla <- head(Order_abundance$Order[order(Order_abundance$Value, decreasing = TRUE)],20)

# Classify other phyla as 'Others'
tmp <- tmp %>%
  mutate(Order2 = ifelse(Order %in% top_phyla, paste0(Order), "Others"))

# total abundance per species
sample_abundance <- tmp %>%
  group_by(Name) %>%
  summarize(TotalValue = sum(Value))

# Merge the total sample abundance with the data
tmp <- merge(tmp, sample_abundance, by = "Name")

# Calculate the relative abundances
tmp$RelativeAbundance <- tmp$Value / tmp$TotalValue

# Sort the data within each sample by increasing relative abundance
tmp <- tmp %>%
  group_by(Name) %>%
  arrange(RelativeAbundance)

tmp$Order2[which(tmp$Order== "o__NA")] <- "unidentified"

#cool function to make names pretty
simplify_A <- function(value) {
  if (value == "Others") {
    return("Others")
  } else {
    simplified <- sub("^.*?o__(\\w+).*?$", "o__\\1", value)
    ifelse(grepl("NA", simplified), sub("; NA.*?$", "; unknown", simplified), simplified)
  }
}


# Apply the function to create column B
tmp$Order3 <- sapply(tmp$Order2, simplify_A)

tmp <- tmp %>%
  dplyr::select(-Order)%>%
  rename(Order = Order3)

# Define the manual colors for six levels
custom_colors23<- c("#774C22", "#965326", 
                     "#FFE898", 
                     "#C1A13E", 
                     "#5D641E",
                     "#BAD0C4",
                     "#7CAED1", "#98D3F1", 
                       "#EFEFBB", "#FFD34C",
                     "#dad7cd", "#386641", "#A7C957", "#a3b18a", "#B5E48C", "#432818","#F67E13", "#BC3853", "#F3E762", "#64146E", "#A36A69", "#fc03ec", "#a81513") 

#plot phyla
E <- tmp %>%
    mutate(Name = gsub("_", " ", Name)) %>% 
    ggplot(aes(x=Name, y=RelativeAbundance, fill=Order)) +
    geom_bar(position="stack", stat="identity") +
    labs(x=NULL, y="", fill="Order") +
    scale_fill_manual(values= custom_colors23) +
    coord_flip() + scale_x_discrete(limits = rev(levels(as.factor(tmp$Name))))+
    theme_bw() +
    theme(legend.position = "right",axis.text.y = element_text(face = "italic")) +
    ggtitle("Leaf")
    
E

## root
root <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")

#root$motus$Phylum_Class_Order <- paste0(root$motus$Phylum, ";", " ", root$motus$Class, ";", " ",root$motus$Order)

root$motus$Order <- paste0("o__",root$motus$Order)

# Aggregate the metabarlist at the class level
root_order <-  aggregate_motus(root, groups= root$motus$Order)
root_order$samples$Species <- str_sub(root_order$samples$Species,1,-2)
root_order$samples$Name <- paste0(substr(root_order$samples$Genus, 1, 1), ".", " ", root_order$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(root_order$reads, by = list(
    paste(root_order$samples$Name)), sum))

colnames(tmp) <- c("Name", "Order", "Value")

# Calculate the total abundance per Class
Order_abundance <- aggregate(Value ~ Order, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(Order_abundance$Value)
Order_proportions <- Order_abundance %>% mutate(Proportion = Value / total_sum *100)
Order_proportions

top_10_proportions <- Order_proportions %>% 
  arrange(desc(Proportion)) %>% 
  head(10)

   Order  Value Proportion
1           o__Frankiales 169232  27.249599
2          o__Rhizobiales  78283  12.605065
3           o__Bacillales  48140   7.751464
4  o__Solirubrobacterales  36430   5.865929
5      o__Burkholderiales  34908   5.620858
6         o__Polyangiales  30176   4.858915
7    o__Corynebacteriales  23685   3.813739
8        o__Rickettsiales  17772   2.861633
9                   o__NA  16771   2.700453
10     o__Lactobacillales  12950   2.085198

# Sort the data by the total abundance in descending order
top_phyla <- head(Order_abundance$Order[order(Order_abundance$Value, decreasing = TRUE)],20)

# Classify other phyla as 'Others'
tmp <- tmp %>%
  mutate(Order2 = ifelse(Order %in% top_phyla, paste0(Order), "Others"))

# total abundance per species
sample_abundance <- tmp %>%
  group_by(Name) %>%
  summarize(TotalValue = sum(Value))

# Merge the total sample abundance with the data
tmp <- merge(tmp, sample_abundance, by = "Name")

# Calculate the relative abundances
tmp$RelativeAbundance <- tmp$Value / tmp$TotalValue

# Sort the data within each sample by increasing relative abundance
tmp <- tmp %>%
  group_by(Name) %>%
  arrange(RelativeAbundance)

tmp$Order2[which(tmp$Order== "o__NA")] <- "unidentified"

# Apply the function to create column B
tmp$Order3 <- sapply(tmp$Order2, simplify_A)

tmp <- tmp %>%
  dplyr::select(-Order)%>%
  rename(Order = Order3)

tmp <- tmp %>%
  dplyr::select(-Order)%>%
  rename(Order = Order3)
#plot phyla
F <- tmp  %>%
    mutate(Name = gsub("_", " ", Name)) %>% 
    ggplot(aes(x=Name, y=RelativeAbundance, fill=Order)) +
    geom_bar(position="stack", stat="identity") +
    labs(x=NULL, y="", fill="Order") +
    scale_fill_manual(values= custom_colors20) +
    coord_flip() + scale_x_discrete(limits = rev(levels(as.factor(tmp$Name))))+
    theme_bw() +
    theme(legend.position = "right",axis.text.y = element_text(face = "italic")) +
    ggtitle("Root")
    
F

Order <- ggarrange(E, F, ncol = 1, nrow = 2)

ggsave("./results/Order_bacteria.jpeg", Order, width = 8, height = 10)
```

## Common genus
```{r}
load("./results/Metabarlist_natura_clean_16S.Rdata")

natura_clean$motus$Genus <- paste0("g__",natura_clean$motus$Genus)

# Aggregate the metabarlist at the class level
#natura_clean_Genus <-  aggregate_motus(natura_clean, groups= natura_clean$motus$Phylum_Class_Genus)
natura_clean_Genus <-  aggregate_motus(natura_clean, groups= natura_clean$motus$Genus)
natura_clean_Genus$samples$Species <- str_sub(natura_clean_Genus$samples$Species,1,-2)
natura_clean_Genus$samples$Name <- paste0(substr(natura_clean_Genus$samples$Genus, 1, 1), ".", " ", natura_clean_Genus$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(natura_clean_Genus$reads, by = list(
    paste(natura_clean_Genus$samples$Name)), sum))

colnames(tmp) <- c("Name", "Genus", "Value")

# Calculate the total abundance per Class
Genus_abundance <- aggregate(Value ~ Genus, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(Genus_abundance$Value)
Genus_proportions <- Genus_abundance %>% mutate(Proportion = Value / total_sum *100)


leaf <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")

#leaf$motus$Phylum_Class_Order <- paste0(leaf$motus$Phylum, ";", " ", leaf$motus$Class, ";", " ",leaf$motus$Order)

leaf$motus$Genus <- paste0("g__",leaf$motus$Genus)

# Aggregate the metabarlist at the class level
#leaf_Genus <-  aggregate_motus(leaf, groups= leaf$motus$Phylum_Class_Genus)
leaf_Genus <-  aggregate_motus(leaf, groups= leaf$motus$Genus)
leaf_Genus$samples$Species <- str_sub(leaf_Genus$samples$Species,1,-2)
leaf_Genus$samples$Name <- paste0(substr(leaf_Genus$samples$Genus, 1, 1), ".", " ", leaf_Genus$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(leaf_Genus$reads, by = list(
    paste(leaf_Genus$samples$Name)), sum))

colnames(tmp) <- c("Name", "Genus", "Value")

# Calculate the total abundance per Class
Genus_abundance <- aggregate(Value ~ Genus, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(Genus_abundance$Value)
Genus_proportions <- Genus_abundance %>% mutate(Proportion = Value / total_sum *100)

## root
root <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")

#root$motus$Phylum_Class_Genus <- paste0(root$motus$Phylum, ";", " ", root$motus$Class, ";", " ",root$motus$Genus)

root$motus$Genus <- paste0("o__",root$motus$Genus)

# Aggregate the metabarlist at the class level
root_Genus <-  aggregate_motus(root, groups= root$motus$Genus)
root_Genus$samples$Species <- str_sub(root_Genus$samples$Species,1,-2)
root_Genus$samples$Name <- paste0(substr(root_Genus$samples$Genus, 1, 1), ".", " ", root_Genus$samples$Species)

# Aggregate per organ/genus
tmp <-  melt(aggregate(root_Genus$reads, by = list(
    paste(root_Genus$samples$Name)), sum))

colnames(tmp) <- c("Name", "Genus", "Value")

# Calculate the total abundance per Class
Genus_abundance <- aggregate(Value ~ Genus, data = tmp, sum)
options(scipen = 999)
total_sum <- sum(Genus_abundance$Value)
Genus_proportions <- Genus_abundance %>% mutate(Proportion = Value / total_sum *100)
Genus_proportions

```


#Add leaf traits
```{r}
load("./results/Metabarlist_natura_clean_16S.Rdata")
summary_metabarlist(natura_clean)

traits <- read.csv("E:/DRYER_natura_data/traits/DRYER_natura_traits.csv") %>% rename(code = Code) %>% dplyr::select(-Family, - Genus, -Species)

traits$code <- as.character(traits$code)

natura_clean$samples <- left_join(natura_clean$samples, traits, by = "code")

row.names(natura_clean$samples) <- natura_clean$samples$sample_id

#with traits
save(natura_clean, file = "./results/Metabarlist_natura_clean_16S_traits.Rdata")

```



#get final summary
```{r}

##
###ESSAI
pseq$samples$nb_motus <- rowSums(pseq$reads>0) #get number of OTUs per sample

leaf3<- melt(pseq$samples,id = c("name", "nb_motus"))
##

#LEAF
load("./results/Metabarlist_natura_clean_16S_leaf.Rdata")
summary(leaf_metabar_clean)

leaf_metabar_clean$samples$nb_reads <- rowSums(leaf_metabar_clean$reads) #get number of reads per sample
leaf_metabar_clean$samples$nb_motus <- rowSums(leaf_metabar_clean$reads>0) #get number of OTUs per sample

#to get number of motus and reads
leaf2 <- melt(leaf_metabar_clean$samples,id = c("name", "nb_reads", "nb_motus"))

leaf3 <- leaf2 %>%
  group_by(name) %>%
  summarise(mean_nb_reads = round(mean(nb_reads)), 
            mean_nb_motus = round(mean(nb_motus)))

#to get number of samples (leaf) per species
leaf <- leaf2 %>%
  filter(variable == "sample_id") %>%
  group_by(name) %>%
  summarise(n= n())

#table of number of reads, OTU and samples per species
table_leaf <- left_join(leaf3, leaf) 
table_leaf$organ <- "leaf"

#-------------------------------------------------------------------
#ROOT
load("./results/Metabarlist_natura_clean_16S_root.Rdata") #name: root_metabar_clean
summary(root_metabar_clean)


root_metabar_clean$samples$nb_reads <- rowSums(root_metabar_clean$reads) #get number of reads per sample
root_metabar_clean$samples$nb_motus <- rowSums(root_metabar_clean$reads>0) #get number of OTUs per sample

#to get number of motus and reads
root2 <- melt(root_metabar_clean$samples,id = c("name", "nb_reads", "nb_motus"))

root3 <- root2 %>%
  group_by(name) %>%
  summarise(mean_nb_reads = round(mean(nb_reads)), 
            mean_nb_motus = round(mean(nb_motus)))

#to get number of samples (root) per species
root <- root2 %>%
  filter(variable == "sample_id") %>%
  group_by(name) %>%
  summarise(n= n())

#table of number of reads, OTU and samples per species
table_root <- left_join(root3, root) 
table_root$organ <- "root"


#join root and leaf table

table <- rbind(table_root, table_leaf) %>%
  relocate(organ, .before =name) %>%
  relocate(n, .before = mean_nb_reads) %>%
  mutate(name = gsub("_", " ", name)) %>%
  rename(Species = name) 
  

table %>%
  dplyr::select(-organ) %>% #remove it otherwise redundant
  kbl(caption = "Curated data for 16S : number of replicates, mean number of reads and OTUs per species.", escape = FALSE) %>% #title
  pack_rows(index = c("root" = 7, "leaf" = 7)) %>% #to group by organ
  row_spec(0, bold = TRUE) %>% #first row is in bold
  column_spec(1, italic = T) %>% #make species name in italic
  kable_classic(full_width = F, html_font = "Cambria") %>%
  save_kable(file = "./results/summary_16S.png") #make it bigger add zoom = 5 in save_kable


```

