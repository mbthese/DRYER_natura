---
title: "metabaR"
author: "Marion Boisseaux"
date: "2/16/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#Package nécessaire
# install bioconductor dependencies
#install.packages("BiocManager")
#BiocManager::install("biomformat")

# install metabaR package
#install.packages("remotes")
#remotes::install_github("metabaRfactory/metabaR")

library(ape) #read fasta files
library(ggplot2)
library(ggpubr)
library(reshape2)
library(metabaR)
library(readr)
library(dplyr)
library(tidyverse)
library(tidyr)
library(stringr)
library(kableExtra)
```

#MetabarList

Creation de la MetarbarList avec les 4 objets:

*Motus : Motus en ligne et leur attributs en colonne (séquence, assignation, score d’assignation, etc)*
*PCR : PCRs en ligne et leur attributs en colonne (sample_id, type, type_de_contrôle)*
*Reads : une table avec les séquences en ligne et les Motus (abondance) en colonne*
*Sample : les échantillons en ligne et leurs infos associer en colonne (position GPS, altitude, milieu de prélèvement, etc). Mais si non disponible la liste des échantillons suffit*

```{r MetabarList, include=FALSE}
#samples file preparation for the conversion
file_samples <- read.delim2("E:/DRYER_natura_data/16S/ngs_filter_16S.tab", header = FALSE)
file_samples <-as.data.frame(sapply(file_samples, function(x) gsub("\"", "", x)))
samples  <- file_samples %>%
  #select(project, organ, marker, samples_name, Family, Genus, Species) %>%
  rename(project = V1) %>%
  rename(sample_id = V2) %>%
  rename(tag = V3) %>%
  rename(primer_forward = V4) %>%
  rename(primer_reverse = V5) %>%
  rename(info = V6) %>%
  relocate(sample_id, .before = project) %>%
  separate(info, into = c('Family', 'Genus', 'Species'), sep = ",") %>%
  separate(Family, into = c('VX', 'Family'), sep = "=") %>%
  separate(Species, into = c("Species", "VXX"), sep = ";")%>%
    select(-tag, -primer_forward, -primer_reverse, -VX, -VXX)


samples <- samples %>% separate(sample_id, into = c("project", "s_project", "organ", "marker", "type", "code", "control_type"), sep = "_", remove = FALSE)

samples$CODE <- ifelse(grepl("^\\d+$", samples$code), samples$code, NA) #regular expression "^\\d+$" to match strings that contain only digits. The ^ and $ anchors ensure that the entire string is matched.  If the value matches the pattern, we assign it to the new column numeric_col, otherwise we assign NA.
samples$CONTROL_TYPE <- ifelse(grepl("\\D+", samples$code), samples$code, NA) #the pattern \\D+ to match one or more non-digit characters. If the value matches the pattern, we assign it to the new column character_col, otherwise we assign NA.


samples$CODE <- ifelse(is.na(samples$CODE), samples$control_type, samples$CODE)

samples <- samples %>%
  dplyr::select(-code, -control_type)%>%
  rename(code = CODE,
         control_type = CONTROL_TYPE) %>%
  relocate(control_type, .after = type) %>%
  relocate(code, .after = control_type)

samples$sample_id <- gsub("sample_", "", samples$sample_id)
rownames(samples) <- samples$sample_id
#unique samples meanwhile re-running the pipeline with the numbered controls.
# samples_unique <- samples[!duplicated(samples$sample_id),]
# samples_unique$sample_id <- gsub("sample_", "", samples_unique$sample_id)
# rownames(samples_unique) <- samples_unique$sample_id
# samples_unique <- samples_unique %>% separate(sample_id, into = c("project", "s_project", "organ", "marker", "code"), sep = "_", remove = FALSE)
#write.table(file_samples, file = "E:/DRYER_natura_data/16S/filesamples.txt", sep ="\t")

#pcrs
ngsfilter <-read.delim2("E:/DRYER_natura_data/16S/ngs_filter_16S.tab", header = FALSE)
ngsfilter <-as.data.frame(sapply(ngsfilter, function(x) gsub("\"", "", x)))
pcrs <- ngsfilter %>%
  rename(project = V1) %>%
  rename(sample_id = V2) %>%
  rename(tag = V3) %>%
  mutate(type = str_detect(sample_id, 'sample')) %>%
  mutate(type = ifelse(type %in% TRUE, 'sample', 'control')) %>%
  mutate(control_type = ifelse(str_detect(type, 'sample'), NA,
                               ifelse(str_detect(sample_id, 'sterilisation'), 'sequencing',  #i put sequencing but it's actually sterilisation. just to make sure the metabarlist works
                                      ifelse(str_detect(sample_id, 'extraction'), 'extraction', 'pcr')))) %>%
  select(sample_id, type, control_type)

pcrs$sample_id <- gsub("sample_", "", pcrs$sample_id)

pcrs <- pcrs %>% 
  separate(sample_id, into = c("project", "s_project", "organ", "marker", "A", "CODE", "B"), sep = "_", remove = FALSE) %>%
  dplyr::select(-CODE)

pcrs$code<- ifelse(grepl("^\\d+$", pcrs$A), pcrs$A, NA) #regular expression "^\\d+$" to match strings that contain only digits. The ^ and $ anchors ensure that the entire string is matched.  If the value matches the pattern, we assign it to the new column numeric_col, otherwise we assign NA.

pcrs$code <- ifelse(is.na(pcrs$code), pcrs$B, pcrs$code)

pcrs <- pcrs %>%
  dplyr::select(-A, -B)

pcrs <- pcrs[!duplicated(pcrs$sample_id),]
rownames(pcrs) <- pcrs$sample_id
#write.table(pcrs, file= "E:/DRYER_natura_data/16S/pcrs.txt", sep ="\t")

#obifile
file_obitab <- read.delim2("E:/DRYER_natura_data/16S/DRYER_natura_R1R2_good_demultiplexed_derepl_basicfilt_cl_agg_06042023.tab")
#colnames(file_obitab)
colnames(file_obitab) <- gsub("sample.", "", colnames(file_obitab)) # remove the pattern 'sample.' from column names

#read
colnames(file_obitab)
read <- file_obitab %>% select(c(1,20:184))
read_t <- t(read[,-1])
read_t <- as.data.frame(read_t)
colnames(read_t) <- read$id
read_t[is.na(read_t)] <- 0 #Replace na values with 0 using is.na()
read_t <- as.matrix(read_t)

#motus
motus <- file_obitab[, c(1,3,19,205)] #take the sequence column
rownames(motus) <- motus$id

#does not work
assign <- read.csv("E:/DRYER_natura_data/16S/Assignation/assignation06042023_with_quality_score.csv", header = TRUE)
assign <- assign %>% 
  dplyr::select(-sequence,-ncbi) %>%
  rename(id = cluster.acc)
assign_motus <- left_join( motus, assign, by = "id") #on perd certain motus, non assignés.#dim 7473 au lieu de 7634
assign_motus<- assign_motus %>% separate(path, into = c('domain','phylum', 'class', 'order'), sep = ";", FALSE)
assign_motus<- assign_motus %>% mutate(taxo_long = paste0(phylum,"_", class, "_", order))
assign_motus<- assign_motus %>% mutate(taxo_court = paste0(phylum,"_", class))

#with read.csv("E:/DRYER_natura_data/16S/Assignation/assignation06042023.csv", header = TRUE) #summary(assign_motus$base_pair) #mean 300, range (93-410)
A <- unique(assign_motus$silva) #to know how many unique OTU I have #1239
rownames(assign_motus) <- assign_motus$id

#dimensions are not the same, so investigate missing controls
read_t_essai <- as.data.frame(read_t)
setdiff(rownames(pcrs),rownames(read_t_essai))
# [1] "DRYER_natura_NA_16S_control_extraction_5" "DRYER_natura_NA_16S_control_PCR_21"      
# [3] "DRYER_natura_NA_16S_control_PCR_22" 

#remove missing controls
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_21")
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_22")
pcrs <- pcrs %>% filter(sample_id != "DRYER_natura_NA_16S_control_extraction_5")


samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_21")
samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_PCR_22")
samples <- samples %>% filter(sample_id != "DRYER_natura_NA_16S_control_extraction_5")


#Metabarlist
MetabarList <- metabarlist_generator(reads = read_t , #165*7634 #not okay
                                     motus = assign_motus, #7634*11 #ok
                                     pcrs = pcrs,  #165*8 #ok
                                     samples = samples) #165*11
```

# Diagnostic plots

Basic stats on the raw data

```{r}
# Compute the number of reads per pcr
MetabarList$pcrs$nb_reads <- rowSums(MetabarList$reads)
summary(MetabarList$pcrs$nb_reads) #il y en a que 1
sum(MetabarList$pcrs$nb_reads) #2,032,280 de reads; mean: 12317
Nbr_reads <- MetabarList$pcrs

#total number of reads
sum(Nbr_reads$nb_reads) #[1] 2032280

#number of reads for all samples, removing control
Nbr_samples <-Nbr_reads %>% filter(type != "control") 
sum(Nbr_samples$nb_reads) #[1] 1953583

#number of reads for the leaf & root
leaf <- Nbr_samples %>% filter(organ != "leaf") 
sum(leaf$nb_reads) #[1] 875699
root <- Nbr_samples %>% filter(organ != "root") 
sum(root$nb_reads) #[1] 1077884

#removing reads below 300 reads
Nbr_samples <- Nbr_samples %>% filter(nb_reads > 300)
summary(Nbr_samples$nb_reads)
   # Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   # 2104   10101   12738   14800   17192   52730 
  
A <- ggplot(Nbr_reads, aes(x = nb_reads, fill = type))+
  geom_histogram() +
   theme_minimal() +
  theme(legend.position = "bottom")+
  theme(text = element_text(size = 12))
 

B <- ggplot(Nbr_samples, aes(x = nb_reads))+ #histogram on the samples only after removing one individual leaf that had a low number of reads
  geom_histogram() +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 40000, by = 5000))+
    theme(text = element_text(size = 12))

ggarrange(A, B, labels = c("nr_reads for all with controls" ,"nb_reads for samples (leaf & root)"))

# Compute the number of motus per pcr
MetabarList$pcrs$nb_motus <- rowSums(MetabarList$reads>0)
summary(MetabarList$pcrs$nb_motus <181) #only 1 beneath 181 at 8.
#average: 584.4 per samples

length(MetabarList$motus$sequence)
# 7634 #nombre d'OTUs unique.

# Create an input table (named check1) for ggplot of 3 columns: 
#  (i) control type 
#  (ii) a vector indicated whether it corresponds to nb_reads or nb_motus, 
#  (iii) the corresponding values.

check1 <- melt(MetabarList$pcrs[,c("control_type", "nb_reads", "nb_motus")])
check1$control_type[which(check1$control_type == "sequencing")] <- "sterilisation"
ggplot(data <- check1, aes(x=control_type, y=value, color=control_type)) + 
  geom_boxplot() + theme_bw() + 
  geom_jitter(alpha=0.2) + 
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  facet_wrap(~variable, scales = "free_y") + 
  theme(axis.text.x = element_text(angle=45, h=1))

# Using the nb_reads and nb_motus defined previously

ggplot(MetabarList$pcrs, aes(x=nb_reads, y=nb_motus, color = control_type)) + 
  geom_point() + theme_bw() + 
  scale_y_log10() + scale_x_log10() + 
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey")



# Check results
summary_metabarlist(MetabarList)
```


# Rarefaction curves

```{r eval=FALSE, include=FALSE}
natura.raref = hill_rarefaction(MetabarList, nboot = 20, nsteps = 10)
head(natura.raref$hill_table)
gghill_rarefaction(natura.raref)

# Define a vector containing the Material info for each pcrs
material <- MetabarList$samples$Genus[match(MetabarList$pcrs$sample_id,
                                                rownames(MetabarList$samples))]

# Use of gghill_rarefaction requires a vector with named pcrs
material <- setNames(material,rownames(MetabarList$pcrs))

# Plot
p <- gghill_rarefaction(natura.raref, group=material) #contamination en vert sur le premier graphe??
```

# Detecting contaminants

Due to the tagjump bias, many genuine MOTUs that are abundant in samples can be detected in negative controls. Consequently, simply removing from the dataset any MOTU that occurs in negative controls is a **very bad idea.**

The function *contaslayer* relies on this assumption and detects MOTUs whose relative abundance across the whole dataset is highest in negative controls. Note however that this approach won’t be appropriate if the negative controls have been contaminated with biological samples. In this case,contaslayer should identify MOTUs that are dominants in samples.

The function contaslayer adds a new column in table motus indicating whether the MOTU is a genuine MOTU **TRUE** or a contaminant *FALSE*.

## sterilisation contaminants

```{r}
natura <- contaslayer(MetabarList,
                         control_types = "sequencing", #but sterilization
                         output_col = "not_a_sterilisation_conta")

table(natura$motus$not_a_sterilisation_conta)
# FALSE  TRUE 
#    62  7572 

# Identify the most common contaminant
# get contaminant ids
conta_sterilisation <- natura$motus$path[which(natura[["motus"]][["not_a_sterilisation_conta"]] == FALSE)]

conta_sterilisation<- as.data.frame(conta_sterilisation)
conta_sterilisation<- conta_sterilisation %>% separate(conta_sterilisation, into = c('domain','phylum', 'class', 'order', 'family', 'genus'), sep = ";", FALSE)

conta_sterilisation <- conta_sterilisation %>% 
  rename(path = conta_sterilisation)

conta_sterilisation <- left_join(conta_sterilisation, natura$motus)

# Compute relative abundance of all pcr contaminants together
a <- data.frame(conta.relab.sterilisation = rowSums(natura$reads[,!natura$motus$not_a_sterilisation_conta]) /
                                    rowSums(natura$reads))
# Add information on control types
a$control_type <- natura$pcrs$control_type[match(rownames(a), rownames(natura$pcrs))]

ggplot(a, aes(x=control_type, y=conta.relab.sterilisation, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10()

```



## pcrs contaminants
```{r}
natura <- contaslayer(natura,
                         control_types = "pcr",
                         output_col = "not_a_pcr_conta")

table(natura$motus$not_a_pcr_conta)
# FALSE  TRUE 
#   580  7054 

# Identify the most common contaminant
# get contaminant ids

conta_pcr <- natura$motus$path[which(natura[["motus"]][["not_a_pcr_conta"]] == FALSE)]
conta_pcr <- as.data.frame(conta_pcr)


conta_pcr<- conta_pcr %>% separate(conta_pcr, into = c('domain','phylum', 'class', 'order', 'family', 'genus'), sep = ";", FALSE)

conta_pcr <- conta_pcr %>% 
  rename(path = conta_pcr)

conta_pcr <- left_join(conta_pcr, natura$motus)

# Compute relative abundance of all pcr contaminants together
a$conta.relab.pcr <- rowSums(natura$reads[,!natura$motus$not_a_pcr_conta]) /
                                    rowSums(natura$reads)

ggplot(a, aes(x=control_type, y=conta.relab.pcr, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10()

```


## extraction contaminants

```{r extraction contaminants}

natura <- contaslayer(natura,
                         control_types = "extraction",
                         output_col = "not_an_extraction_conta")

table(natura$motus$not_an_extraction_conta)
#> 
#FALSE  TRUE 
 #  56  7578 
conta_extraction <- natura$motus$path[which(natura[["motus"]][["not_an_extraction_conta"]] == FALSE)]
conta_extraction <- as.data.frame(conta_extraction)

conta_extraction<- conta_extraction %>% separate(conta_extraction, into = c('domain','phylum', 'class', 'order', 'family', 'genus'), sep = ";", FALSE)

conta_extraction <- conta_extraction %>% 
    rename(path = conta_extraction)

conta_extraction <- left_join(conta_extraction, natura$motus)

# Compute relative abundance of all pcr contaminants together

a$conta.relab.extraction <- rowSums(natura$reads[,!natura$motus$not_an_extraction_conta]) /
                                    rowSums(natura$reads)

ggplot(a, aes(x=control_type, y=conta.relab.extraction, color=control_type)) +
  geom_boxplot() + geom_jitter(alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  labs(x=NULL, y="Prop. Reads (log10)") +
  theme_bw() +
  scale_y_log10() #ca va pas trop de conta dans les echantillons

```

##flag contaminants

Overall, samples yield much less amounts of extraction contaminants than experimental negative controls. No pcrs corresponding to samples have > 10% of their reads corresponding to contaminants. We can still flag the controls:

```{r}
#flag pcrs with total contaminant relative abundance > 10% of reads
#1 for contaminants that came from pcr
#2 for contaminants that came from extraction

#to get the detail
# natura$pcrs$low_contamination_level <-
#   ifelse(a$conta.relab.sterilisation[match(rownames(natura$pcrs), rownames(a))]>1e-1,  1, 
#   ifelse(a$conta.relab.extraction[match(rownames(natura$pcrs), rownames(a))]>1e-1,  2,
#   ifelse(a$conta.relab.pcr[match(rownames(natura$pcrs), rownames(a))]>1e-1, 3, 0)))

#to do it all at once
natura$pcrs$low_contamination_level <-
  ifelse(a$conta.relab.sterilisation[match(rownames(natura$pcrs), rownames(a))]>1e-1,  F, 
  ifelse(a$conta.relab.extraction[match(rownames(natura$pcrs), rownames(a))]>1e-1,  F,
  ifelse(a$conta.relab.pcr[match(rownames(natura$pcrs), rownames(a))]>1e-1, F, T)))

# Proportion of potentially functional (TRUE) vs. failed (FALSE) pcrs
# (controls included) based on this criterion
table(natura$pcrs$low_contamination_level) / nrow(natura$pcrs)
#0, 0.94545455 : no contamination (all samples)       
#1, 0.01212121 : conta from sterilisation (2, one from the sterilisation and one pcrs)   
#2  0.03030303 : conta from extraction (5: 2 ext + 3 pcr) 
#3  0.01212121 : conta from pcr (2 pcr)


#all at once
#      FALSE       TRUE 
# 0.05454545 0.94545455 
```

## spurious or non-target MOTUs

Non-target sequences can be amplified if the primers are not specific enough. On the other hand, some highly degraded sequences can be produced throughout the data production process, such as primer dimers, or chimeras from multiple parents (hereafter referred to as spurious MOTUs). To detect these, one can use the information related to taxonomic assignments and associated similarity scores.

Since the dataset was obtained with primers that target 16S, other MOTUs should be excluded. At this stage of the analysis, we only flag MOTUs based on this criterion.

```{r}
#Flag MOTUs corresponding to target (TRUE) vs. non-target (FALSE) taxa
natura$motus$target_taxon <- grepl("Bacteria", natura$motus$path)

# Proportion of each of these over total number of MOTUs
table(natura$motus$target_taxon) / nrow(natura$motus)

#   FALSE       TRUE 
# 0.02384071 0.97615929
#ce sont des archées

# Intersection with extraction contaminant flags (not contaminant = T)
table(natura$motus$target_taxon,
      natura$motus$not_a_sterilisation_conta) #5 MOTUs as non-taget, which were already flagged as potential sterilisation conta

table(natura$motus$target_taxon,
      natura$motus$not_an_extraction_conta) #4 MOTUs as non-taget, which were already flagged as potential ext conta

table(natura$motus$target_taxon,
      natura$motus$not_a_pcr_conta) #29 MOTUs as non-taget, which were already flagged as potential pcr conta
```

Next, we want to identify MOTUs whose sequence is too dissimilar from references. This filtering criterion relies on the assumption that current reference databases capture most of the diversity at broad taxonomic levels (i.e. already have for example at least one representative of each phyla). Considering this, MOTUs being too distant from reference databases are more likely to be a degraded sequence, especially if such MOTUs are relatively numerous and of low abundance. To assess this, one can use the distribution of MOTU similarity scores, weighted and unweighted by their relative abundance.

```{r}
# Plot the unweighted distribution of MOTUs similarity scores
a <-
  ggplot(natura$motus, aes(x=similarity)) +
  geom_histogram(color="grey", fill="white", bins=20) +
  geom_vline(xintercept = 80, col="orange", lty=2) +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  labs(x="% similarity against best match", y="# MOTUs")

#But silva lready filtered the MOTU correspondances
# classification similarity
# 93
# The minimal percent similarity to the closest relative as reported by BLAST according to ((alignment coverage + alignment quality)/2) that is used for classification.
```

## detecting PCR outliers

A first way to identify failed PCRs is to flag them based on the pcr sequencing depth

```{r}
ggplot(natura$pcrs, aes(nb_reads, fill= type)) +
    geom_histogram(bins=40, color="grey") +
    geom_vline(xintercept = 1e3, lty=2, color="orange") + # threshold
    scale_x_log10() +
    labs(x="# Reads (with all MOTUs and PCRs)",
        y="# PCRs") +
    theme_bw() +
    theme(panel.grid = element_blank())
#fortunately, samples yield high amount of reads.
# Flag pcrs with an acceptable sequencing depth (TRUE) or inacceptable one (FALSE)
natura$pcrs$seqdepth_ok <- ifelse(natura$pcrs$nb_reads < 1e3, F, T)

# Proportion of each of these over total number of pcrs, control excluded
table(natura$pcrs$seqdepth_ok[natura$pcrs$type=="sample"]) /
  nrow(natura$pcrs[natura$pcrs$type=="sample",])
# 
# FALSE        TRUE 
# 0.007518797 0.992481203 

```

## lowering tag-jumps

Tag-jumps are frequency-dependent, i.e. abundant genuine MOTUs are more likely to be found in low abundance in samples were they are not supposed to be than rare genuine MOTUs. To reduce the amount of such false positives, the function tagjumpslayer considers each MOTU separately and corrects its abundance in pcrs (see tagjumpslayer help for more information on possible correction methods) when the MOTU relative abundance over the entire dataset is below a given threshold. Such data a curation strategy is similar to what has been proposed by Esling, Lejzerowicz, and Pawlowski (2015). Effect of this threshold can be evaluated by testing how this filtration procedure affects basic dataset characteristics (e.g. # MOTUs or reads) at different levels, as exemplified below.

```{r}
# Define a vector of thresholds to test
thresholds <- c(0,1e-4,1e-3, 1e-2, 3e-2, 5e-2)

# Run the tests and stores the results in a list
tests <- lapply(thresholds, function(x) tagjumpslayer(natura,x))
names(tests) <- paste("t_", thresholds, sep="")

# Format the data for ggplot with amount of reads at each threshold
tmp <- melt(as.matrix(do.call("rbind", lapply(tests, function(x) rowSums(x$reads)))))
colnames(tmp) <- c("threshold", "sample", "abundance")

# Add richness in MOTUs at each threshold
tmp$richness <-
  melt(as.matrix(do.call("rbind", lapply(tests, function(x) {
    rowSums(x$reads > 0)
  }))))$value

# Add control type information on pcrs and make data curation threshold numeric
tmp$controls <- natura$pcrs$control_type[match(tmp$sample, rownames(natura$pcrs))]
tmp$threshold <- as.numeric(gsub("t_", "", tmp$threshold))

# New table formatting for ggplot
tmp2 <- melt(tmp, id.vars=colnames(tmp)[-grep("abundance|richness", colnames(tmp))])

ggplot(tmp2, aes(x=as.factor(threshold), y=value)) +
  geom_boxplot(color="grey40") +
  geom_vline(xintercept = which(levels(as.factor(tmp2$threshold)) == "0.01"), col="orange", lty=2) +
  geom_jitter(aes(color=controls), width = 0.2, alpha=0.5) +
  scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
  facet_wrap(~variable+controls, scale="free_y", ncol=4) +
  theme_bw() +
  scale_y_log10() +
  labs(x="MOTU pcr : total abundance filtering threshold", y="# Reads/MOTUs") +
  theme(panel.grid = element_blank(),
        strip.background = element_blank(),
        axis.text.x = element_text(angle=40, h=1),
         legend.position = "none")
# A threshold of 0.01 leads to a drop in both the number of reads and of MOTUs in sequencing negative controls. This drop is also noticeable in terms of the number of MOTUs in pcrs obtained from other controls as compared to those obtained from samples. The former are expected to be void of environmental MOTUs, and tag-jumps should be more visible/important in these pcrs. Note that this procedure primarily affects MOTU diversity in pcrs, and poorly the number of reads in pcrs.
# 
# As for above, pcrs containing large amounts of MOTUs identified as potentially artifactual or where tag-jumps filtering strongly affects the number of reads in pcrs can be flagged as potentially failed
```

## summarizing the noise in the natura dataset

We can now get an overview of the amount of noise identified with the criteria used above, for both the number of MOTUs and their associated readcount.

```{r}
# Create a table of MOTUs quality criteria
# noise is identified as FALSE in natura, the "!" transforms it to TRUE
motus.qual <- !natura$motus[,c("not_an_extraction_conta", "not_a_pcr_conta", "not_a_sterilisation_conta", "target_taxon")]
colnames(motus.qual) <- c("extraction_conta", "pcr_conta", "sterilisation_conta", "untargeted_taxon")

# Proportion of MOTUs potentially artifactual (TRUE) based on the criteria used
prop.table(table(apply(motus.qual, 1, sum) > 0))

# 
#    FALSE     TRUE 
# 0.889704 0.110296 

# Corresponding proportion of artifactual reads (TRUE)
#get the number of reads per motus
natura$motus$count <- colSums(natura$reads>0)
prop.table(xtabs(natura$motus$count~apply(motus.qual, 1, sum) > 0))
#    FALSE      TRUE 
# 0.9347926 0.0652074 

# Proportion of MOTUs and reads potentially artifactual for each criterion
apply(motus.qual, 2, sum) / nrow(motus.qual)
apply(motus.qual, 2, function(x) sum(natura$motus$count[x])/sum(natura$motus$count))

tmp.motus <-
  apply(sapply(1:ncol(motus.qual), function(x) {
    ifelse(motus.qual[,x]==T, colnames(motus.qual)[x], NA)}), 1, function(x) {
      paste(sort(unique(x)), collapse = "|")
      })
tmp.motus <- as.data.frame(gsub("^$", "not_artefactual", tmp.motus))
colnames(tmp.motus) <-  "artefact_type"

ggplot(tmp.motus, aes(x=1, fill=artefact_type)) +
    geom_bar() +  xlim(0, 2) +
    labs(fill="Artifact type") +
    coord_polar(theta="y") + theme_void() +
    scale_fill_brewer(palette = "Set3") +
    theme(legend.direction = "vertical") +
    ggtitle("MOTUs artefacts overview")

# 
# The above shows that MOTUs flagged as potentially artefactual account for ca. 10% of the dataset’s diversity and roughly the same in terms of readcount. Most of these artifact MOTUs are rare and correspond to sequences which are potentially highly degraded, with very low sequence similarity against the EMBL reference database. The most abundant artifacts MOTUs were identified as contaminants.
#let's do the same for pcrs
# Create a table of pcrs quality criteria
# noise is identified as FALSE in natura, the "!" transforms it to TRUE

pcrs.qual <- !natura$pcrs[,c("low_contamination_level", "seqdepth_ok")]
colnames(pcrs.qual) <- c("high_contamination_level", "low_seqdepth")


# Proportion of pcrs potentially artifactual (TRUE) based on the criteria used
# excluding controls
prop.table(table(apply(pcrs.qual[natura$pcrs$type=="sample",], 1, sum) > 0))

# FALSE        TRUE 
# 0.992481203 0.007518797 

# Proportion of MOTUs and reads potentially artifactual for each criterion
apply(pcrs.qual[natura$pcrs$type=="sample",], 2, sum) / nrow(pcrs.qual[natura$pcrs$type=="sample",])
# 
# low_seqdepth high_contamination_level 
#              0.007518797              0.000000000 

tmp.pcrs <-
  apply(sapply(1:ncol(pcrs.qual), function(x) {
    ifelse(pcrs.qual[natura$pcrs$type=="sample",x]==T,
           colnames(pcrs.qual)[x], NA)}), 1, function(x) {
      paste(sort(unique(x)), collapse = "|")
      })
tmp.pcrs <- as.data.frame(gsub("^$", "not_artefactual", tmp.pcrs))

colnames(tmp.pcrs) <- "artefact_type"

ggplot(tmp.pcrs, aes(x=1, fill=artefact_type)) +
    geom_bar() +  xlim(0, 2) +
    labs(fill="Artifact type") +
    coord_polar(theta="y") + theme_void() +
    scale_fill_brewer(palette = "Set3") +
    theme(legend.direction = "vertical") +
    ggtitle("PCR artefacts overview")
```

# Data cleaning and aggregation

The final stage of the analysis consists in removing data based on the criteria defined above and aggregating pcrs to get rid of technical replicates. Here, the decision of which of these flagged criteria to use rests with the user, depending on how they feel the tagged errors impact on the characteristics of their dataset.

## removing spurious signal

First, we will remove suprious MOTUs, PCRs and adjusting read counts by removing tag-jumps . At this stage of the analysis, *controls are no longer necessary*, and so can also be removed from the dataset.

```{r}
# Use tag-jump corrected metabarlist with the threshold identified above
tmp <- tests[["t_0.01"]]

#for pcrs
# Subset on pcrs and keep only controls
tmp_clean <- subset_metabarlist(tmp, "pcrs",
                          indices = rowSums(tmp$pcrs[,c("low_contamination_level","seqdepth_ok")]) == 2 &
                                    tmp$pcrs$type == "sample")
summary_metabarlist(tmp_clean)

# Subset on MOTUs: we keep motus that are defined as TRUE following the
# three criteria below (sum of three TRUE is equal to 3 with the rowSums function)
natura_clean <- subset_metabarlist(tmp_clean, "motus",
                          indices = rowSums(tmp_clean$motus[,c("not_an_extraction_conta", "target_taxon",
                                                 "not_a_pcr_conta", "not_a_sterilisation_conta")]) == 4)
summary_metabarlist(natura_clean)
# 
# $dataset_dimension
#         n_row n_col
# reads     132  6792
# motus    6792    18
# pcrs      132    12
# samples   132    11
# 
# $dataset_statistics
#         nb_reads nb_motus avg_reads sd_reads avg_motus sd_motus
# pcrs     1767613     6792  13391.01 7181.066  512.4924 149.7122
# samples  1767613     6792  13391.01 7181.066  512.4924 149.7122


#check if previsous subsetting lead to NAs
if(sum(colSums(tmp_clean$reads)==0)>0){print("empty motus present")}
if(sum(rowSums(natura_clean$reads)==0)>0){print("empty pcrs present")}

natura_clean$motus$count = colSums(natura_clean$reads)
natura_clean$pcrs$nb_reads_postmetabaR = rowSums(natura_clean$reads)
natura_clean$pcrs$nb_motus_postmetabaR = rowSums(ifelse(natura_clean$reads>0, T, F))

check <- melt(natura_clean$pcrs[,c("nb_reads", "nb_reads_postmetabaR",
                               "nb_motus", "nb_motus_postmetabaR")])
check$type <- ifelse(grepl("motus", check$variable), "richness", "abundance")

ggplot(data = check, aes(x = variable, y = value)) +
  geom_boxplot( color = "darkgrey") +
  geom_jitter(alpha=0.1, color = "darkgrey") +
  theme_bw() +
  facet_wrap(~type, scales = "free", ncol = 5) +
  theme(axis.text.x = element_text(angle=45, h=1)) 

#The sequencing depth was not greatly affected by the trimming. But the richness of pcrs was lowered
```

Let’s now see if the signal is changed in terms of beta diversity:

```{r organ, species}
# Get row data only for samples
tmp <- subset_metabarlist(natura, table = "pcrs",
                          indices = natura$pcrs$type == "sample")

# Add sample biological information for checks
tmp$pcrs$organ <- tmp$samples$organ[match(tmp$pcrs$sample_id, rownames(tmp$samples))]
tmp$samples$name <- paste0(tmp$samples$Genus, "_", tmp$samples$Species)
tmp$pcrs$name <- tmp$samples$name[match(tmp$pcrs$sample_id, rownames(tmp$samples))]
tmp$pcrs$family <- tmp$samples$Family[match(tmp$pcrs$sample_id, rownames(tmp$samples))]

natura_clean$pcrs$organ <-
  natura_clean$samples$organ[match(natura_clean$pcrs$sample_id,
                                        rownames(natura_clean$samples))]

natura_clean$samples$name <- paste0(natura_clean$samples$Genus, "_", natura_clean$samples$Species)
natura_clean$pcrs$name <- natura_clean$samples$name[match(natura_clean$pcrs$sample_id, rownames(natura_clean$samples))]
natura_clean$pcrs$family <- natura_clean$samples$Family[match(natura_clean$pcrs$sample_id, rownames(natura_clean$samples))]


# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = paste(tmp$pcrs$organ, tmp$pcrs$name, sep = " | "))

mds2 <- check_pcr_repl(natura_clean,
                       groups =  paste(natura_clean$pcrs$organ, natura_clean$pcrs$name, sep = " | "))

# Custom colors
a <- mds1 + labs(color = "organ | name") +
#  scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
b <- mds2 + labs(color = "organ | name") +
  #scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  ggtitle("Clean data")

# Assemble plots
species <- ggarrange(a, b, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ_species.jpeg", plot = species, width = 10, height = 8)
```

```{r organ, eval=FALSE, include=FALSE}
# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = paste(tmp$pcrs$organ, tmp$pcrs$family, sep = " | "))

mds2 <- check_pcr_repl(natura_clean,
                       groups =  paste(natura_clean$pcrs$organ, natura_clean$pcrs$family, sep = " | "))

# Custom colors
c <- mds1 + labs(color = "organ | family") +
#  scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
d <- mds2 + labs(color = "organ | family") +
  #scale_color_manual(values = c("brown4", "brown1", "goldenrod4", "goldenrod1")) +
  ggtitle("Clean data")

# Assemble plots
family <- ggarrange(c, d, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ_family.jpeg", plot = family, width = 10, height = 8)
```

```{r eval=FALSE, include=FALSE}
# Build PCoA ordinations
mds1 <- check_pcr_repl(tmp,
                      groups = tmp$pcrs$organ)

mds2 <- check_pcr_repl(natura_clean,
                       groups = natura_clean$pcrs$organ)

# Custom colors
a <- mds1 + labs(color = "organ") +
  scale_color_manual(values = c("#6bbf59", "#E79F02")) +
  theme(legend.position = "none") +
  ggtitle("Raw data")
b <- mds2 + labs(color = "organ") +
  scale_color_manual(values = c("#6bbf59", "#E79F02")) +
  ggtitle("Clean data")

# Assemble plots
organ <- ggarrange(a, b, legend = "bottom" ,common.legend = T)
ggsave(filename = "PCoA_organ.jpeg", plot = organ, width = 10, height = 8)

#for presentation 
pres_organ <- mds2 + labs(color = "organ") +
   scale_color_manual(values = c("#6bbf59", "#E79F02")) +
   theme_light(base_size = 22) +
   theme(legend.position = "none")
ggsave(filename = "PCoA_organ_pres.jpeg", plot = pres_organ, width = 10, height = 8)
```

## data aggregation

normally aggregate the replications, but let's try aggregating the individuals of same species

```{r eval=FALSE, include=FALSE}
#natura_agg <- aggregate_pcrs(natura_clean)
#summary_metabarlist(natura_agg)
```


# Cleaned data

```{r setup, include=FALSE}

knitr::opts_chunk$set(eval = FALSE, include = FALSE)
#no need for below, we have all the info with the NewMetabarlist_clean
#both organs
save(natura_clean, file = "./results/Metabarlist_natura_clean_16S.Rdata")

write.csv(natura_clean$motus,"motus_without_contamiant.csv")
write.csv(t(natura_clean$motus),"transposed_motus_without_contamiant.csv")
write.csv(natura_clean$reads,"reads_without_contamiant.csv")
write.csv(t(natura_clean$reads),"transposed_reads_without_contamiant.csv")
write.csv(natura_clean$samples,"samples_without_contamiant.csv")
write.csv(natura_clean$pcrs,"pcrs_without_contamiant.csv")
write.csv(t(natura_clean$pcrs),"transposed_pcrs_without_contamiant.csv")

#only leaves
leaf_metabar_clean <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "leaf")
save(leaf_metabar_clean, file = "./results/Metabarlist_natura_clean_16S_leaf.Rdata")
write.csv(leaf_metabar_clean$motus,"leaf_motus_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$motus),"leaf_transposed_motus_without_contamiant.csv")
write.csv(leaf_metabar_clean$reads,"leaf_reads_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$reads),"leaf_transposed_reads_without_contamiant.csv")
write.csv(leaf_metabar_clean$samples,"leaf_samples_without_contamiant.csv")
write.csv(leaf_metabar_clean$pcrs,"leaf_pcrs_without_contamiant.csv")
write.csv(t(leaf_metabar_clean$pcrs),"leaf_transposed_pcrs_without_contamiant.csv")

#only roots
root_metabar_clean <- subset_metabarlist(natura_clean, table = "samples",
                          indices = natura_clean$samples$organ == "root")
save(root_metabar_clean, file = "./results/Metabarlist_natura_clean_16S_root.Rdata")
write.csv(root_metabar_clean$motus,"root_motus_without_contamiant.csv")
write.csv(t(root_metabar_clean$motus),"root_transposed_motus_without_contamiant.csv")
write.csv(root_metabar_clean$reads,"root_reads_without_contamiant.csv")
write.csv(t(root_metabar_clean$reads),"root_transposed_reads_without_contamiant.csv")
write.csv(root_metabar_clean$samples,"root_samples_without_contamiant.csv")
write.csv(root_metabar_clean$pcrs,"root_pcrs_without_contamiant.csv")
write.csv(t(root_metabar_clean$pcrs),"root_transposed_pcrs_without_contamiant.csv")
```

# Taxonomic composition -fail
# Visualisation

## phylum
```{r}
# Aggregate the metabarlist at the class level
natura_clean_phy <-
  aggregate_motus(natura_clean, groups= natura_clean$motus$phylum)

# Aggregate per organ/genus
tmp <-  melt(aggregate(natura_clean_phy$reads, by = list(
    paste(natura_clean_phy$samples$organ,
          natura_clean_phy$samples$name,
          sep = " | ")), sum))
#plot phyla
A <- ggplot(tmp, aes(x=Group.1, y=value, fill=variable)) +
    geom_bar(stat="identity") +
    labs(x=NULL, y="#reads", fill="Phyla") +
    coord_flip() + theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle("Bacteria - Phyla")

ggsave(filename = "Bacteria_bargraph.jpeg", plot = A, width = 10, height = 8)

#organ
tmp_organ <-  melt(aggregate(natura_clean_phy$reads, by = list(
    natura_clean_phy$samples$organ), sum))

B <- ggplot(tmp_organ, aes(x=Group.1, y=value, fill=variable)) +
    geom_bar(stat="identity") +
    labs(x=NULL, y="#reads", fill="Phyla") +
    coord_flip() + theme_bw() +
    theme(legend.position = "bottom") +
    ggtitle("Bacteria")
ggsave(filename = "Bacteria_organ_bargraph.jpeg", plot = B, width = 10, height = 8)

#proteobacterie

#firmicutes


```

#get summary
```{r}
load("./results/Metabarlist_natura_clean_16S.Rdata")
summary_metabarlist(natura_clean)

#LEAF
load("./results/Metabarlist_natura_clean_16S_leaf.Rdata")
summary(leaf_metabar_clean)

leaf_metabar_clean$samples$nb_reads <- rowSums(leaf_metabar_clean$reads) #get number of reads per sample
leaf_metabar_clean$samples$nb_motus <- rowSums(leaf_metabar_clean$reads>0) #get number of OTUs per sample

#to get number of motus and reads
leaf2 <- melt(leaf_metabar_clean$samples,id = c("name", "nb_reads", "nb_motus"))

leaf3 <- leaf2 %>%
  group_by(name) %>%
  summarise(mean_nb_reads = round(mean(nb_reads)), 
            mean_nb_motus = round(mean(nb_motus)))

#to get number of samples (leaf) per species
leaf <- leaf2 %>%
  filter(variable == "sample_id") %>%
  group_by(name) %>%
  summarise(n= n())

#table of number of reads, OTU and samples per species
table_leaf <- left_join(leaf3, leaf) 
table_leaf$organ <- "leaf"

#-------------------------------------------------------------------
#ROOT
load("./results/Metabarlist_natura_clean_16S_root.Rdata") #name: root_metabar_clean
summary(root_metabar_clean)


root_metabar_clean$samples$nb_reads <- rowSums(root_metabar_clean$reads) #get number of reads per sample
root_metabar_clean$samples$nb_motus <- rowSums(root_metabar_clean$reads>0) #get number of OTUs per sample

#to get number of motus and reads
root2 <- melt(root_metabar_clean$samples,id = c("name", "nb_reads", "nb_motus"))

root3 <- root2 %>%
  group_by(name) %>%
  summarise(mean_nb_reads = round(mean(nb_reads)), 
            mean_nb_motus = round(mean(nb_motus)))

#to get number of samples (root) per species
root <- root2 %>%
  filter(variable == "sample_id") %>%
  group_by(name) %>%
  summarise(n= n())

#table of number of reads, OTU and samples per species
table_root <- left_join(root3, root) 
table_root$organ <- "root"


#join root and leaf table

table <- rbind(table_root, table_leaf) %>%
  relocate(organ, .before =name) %>%
  relocate(n, .before = mean_nb_reads) %>%
  mutate(name = gsub("_", " ", name)) %>%
  rename(Species = name) 
  

table %>%
  dplyr::select(-organ) %>% #remove it otherwise redundant
  kbl(caption = "Curated data for 16S : number of replicates, mean number of reads and OTUs per species.", escape = FALSE) %>% #title
  pack_rows(index = c("root" = 7, "leaf" = 7)) %>% #to group by organ
  row_spec(0, bold = TRUE) %>% #first row is in bold
  column_spec(1, italic = T) %>% #make species name in italic
  kable_classic(full_width = F, html_font = "Cambria") %>%
  save_kable(file = "./results/summary_16S.png") #make it bigger add zoom = 5 in save_kable


```

